{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Gradys Simulations Simulations from Project GrADyS on OMNET++ and INET framework Introduction This is a repository for the simulation framework developed for the GrADyS project. This framework allows the simulation of interconnected network nodes and the implementation of UAV swarms and sensor coordination strategies with the objective of managing these autonomous UAV swarms to collect sensor data on the field autonomously and efficiently. Gradys Simulations MAVSIMNET a simulation framework for the OMNET++ discrete event simulator based on Ardupilot's Software In The Loop (SITL) simulator. It allows you to enrich OMNeT++ and INET's simulations with realistic mobility models for the mobile nodes in your network. It works by spawning SITL instances that provide a physical simulation of the vehicle's behaviour and connecting them to the mobility classes in your simulation. A user can transparently use these mobility modules without worrying about the details of the communication and messages being exchanged between the network simulator and the SITL instances and a developer can use the strong interface provided in the project's base mobility class to implement his own mobility modules. Installation There are two ways to install and use Gradys-Sim. The first one is to download the provided virtual applience which you can import into any virtual machine software that supports the .ova file format. The second one it to install direcly into your machine 1. Virtualization Just download the virtual applience file (.ova) from this link and import it into any virtual machine software that supports the .ova file format. There should be a user called \"gradys\" with password \"gradys\" already created on imported virtual machine. Oracle's VirtualBox is recommended. Previous versions of this image: OMNeT++ 5.6.2 2. Local Installation In order to run the simulations and use the components in this repository you need to have both OMNeT++ and the INET framework installed. Version 6.0.1 of OMNeT++ is required, to install it just follow these instructions . INET version 4.5.0 is also required, when first opening the OMNeT++ IDE you should be prompted with the option to install INET and all you need to do is accept it but if you need help check out the installation instructions . After installing both OMNeT++ and INET you should be able to clone the repository to your active OMNeT++ IDE workspace. To do this select File > Import... then open the \"git\" section and select \"Projects from git\" then \"Clone Uri\". After that just fill in the URL for this repository and finish the process following the displayed instructions. Make sure you have INET installed in your workspace and that it is selected as project reference. If you see a directory named inet , inet4.5 in your workspace INET is installed and you only need to check if its also selected for the gradys-simulations project. This can be done the following way: Right Click on gradys-simulations project -> Properties -> Project References. Make sure INET is selected here. The sitl file for advanced mobility simulations are already included in the project. However if you would like to use newer versions, download the compiled SITL simulator for each vehicle type you want to use. Save the paths to these files as you will need them later. Binaries can be found on ardupilot's firmware website . These are the binaries for the most common platforms and supported vehicles: Vehicle Windows Linux Copter Link Link Plane Link Link Rover Link Link The same applies to the parameter files for the vehilce types. There are already some defaults included in the project however if you would like to use different or check for the newest version do the following: Write or download parameter files for the vehicle types you want to use. Save the paths to these files as you will need them later. We recommend donwloading the default parameter files from here: Vehicle Location Copter Link Plane Link Rover Link WARNING: You will need to modify the .ini file for the simulations and any other that you run to include your SITL installation paths and parameter file paths for each type of vehicle that you want to use. Usage OMNeT++ simulations are initialized by .ini files. The already provided omnetpp.ini files in the showcases contain some launch configurations for Wifi only communication and shared Wifi and MAM communication, each with configs for one to four UAVs. Launch configurations are defined in the same .ini file denoted by the [Config SOME_NAME]. The [Config Wifi] and [Config MAM] configs are base configs for the other ones and should not be ran. All confiruation files are set to load the simulations on our field test location in Brasilia. If you want to change this you will have to chage these parameters: # Scene's coordinates *.coordinateSystem.sceneLongitude = -47.926634deg *.coordinateSystem.sceneLatitude = -15.840075deg *.coordinateSystem.sceneHeading = 90deg # Vehicle's home coordinates *.quads[*].mobility.homeLatitude = -15.840068deg *.quads[*].mobility.homeLongitude = -47.926633deg # Ground Station's coordinates *.groundStation.mobility.initialLatitude = -15.840068deg *.groundStation.mobility.initialLongitude = -47.926633deg # Sensor's coordinates *.sensors[0].mobility.initialLatitude = -15.84245230deg *.sensors[0].mobility.initialLongitude = -47.92948720deg Aditionally, the quads follow a series of waypoints specified in a waypoint file. You will also need to change these to reasonable waypoints on your simulation's location. Example of a waypoint file: # Numers 9,10 and 11 specify latitude, logitude and altitude QGC WPL 110 0 1 0 16 0 0 0 0 -15.840075 -47.926634 0 1 1 0 3 22 0.00000000 0.00000000 0.00000000 0.00000000 -15.84008500 -47.92663560 20.000000 1 2 0 3 16 0.00000000 0.00000000 0.00000000 0.00000000 -15.84011710 -47.92712550 20.000000 1 3 0 3 16 5.00000000 0.00000000 0.00000000 0.00000000 -15.84019450 -47.92777060 20.000000 1 4 0 3 16 0.00000000 0.00000000 0.00000000 0.00000000 -15.84029000 -47.92860750 20.000000 1 5 0 3 16 5.00000000 0.00000000 0.00000000 0.00000000 -15.84019500 -47.92777060 20.000000 1 6 0 0 177 2.00000000 4.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.000000 1 7 0 0 20 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.000000 1 Recently some more showcases were added. They were created to test and measure the results of a simple simulation with a single drone collecting data from a couple of sensors. The simplicity of these simulations is intentional as it allows us to measure the effect that different parameters have on the collection rate and range of the vehicle. The configs set up simulation campaigns that help us figure out the parameters we should use to better reflect the numbers we observe on real-life experiments. To aid us in interpreting this data we implemented data reporting to the modules used in these configs. When the parameter campaigns run they generate several .vec and other OMNeT++ statistical files. By using OMNeT++'s built in data analysis tools we can extrant information from these runs. To learn more about how to use these files to generate visualizations using the OMNeT++ IDE, check it's User Guida . Here are some examples: Launch configurations dictate the parameters of your simulation and you can change omnetpp.ini to suit your necessities. Here are some of the more important parameters that you can try switching yourself: The number of UAVs and sensors in the simulation: *.numUAVs = 2 // Initializes the *.quad[] array with 2 UAVs *.numSensors = 8 // Initializes the *.sensors[] array with 8 sensors Some UAV (called quads in this file) parameters: // The protocol the UAV will follow (protocols explained further bellow) // Change this to test other protocols like \"ZigzagProtocol\" *.quads[*].protocol.typename = \"DadcaProtocol\" // The UAV's destination addresses (nodes it talks to and recieves messages from) *.quads[0].app[0].destAddresses = \"quads[1] sensors[0] sensors[1] sensors[2] groundStation\" // Start time for the UAV's communication and mobility modules // Change this to expertiment with different start timings *.quads[1].app[*].startTime = normal(40s, 1s) // Here the normal function gives a value 1s within 40s *.quads[1].mobility.startTime = 40s // The waypoint file the UAV should follow *.quads[*].mobility.waypointFile = \"paths/voo_ar.waypoints\" Some sensor parameters: // The sensor's destination addresses *.sensors[*].app[0].destAddresses = \"quads[0] quads[1]\" // The protocol the sensor should follow *.sensors[0..2].protocol.typename = \"DadcaProtocolSensor\" // The sensor's position coordinates *.sensors[0].mobility.initialLatitude = -15.84245230deg *.sensors[0].mobility.initialLongitude = -47.92948720deg To run a simulation simply select one of the .ini files in the showcases and use the OMNeT++ IDE Run option. After the GUI opens select the desired launch configuration and press play on the simulation. For more realistic simulations The mobility modules available in this framework are instances of INET mobility modules. If you do not know what those are or how to use them you can check INET's documentation . There you will learn how to set up a simulation environment, populate it with nodes and set them up with mobility modules . After your simulation is set up there is only a couple things you need to worry about. A very important thing to take note of is that your simulation has to use INET's Real Time Scheduler. This guarantees that the SITL instances and OMNET++ are syncronized. You can set this up in your .ini file with this line: scheduler-class = \"inet::RealTimeScheduler\" Using the available mobility modules is as simple as setting your node's mobility module. You can do this with the following command, using the RandomWaypointMobility module as an example: *.client[*].mobility.typename = \"MAVLinkRandomWaypointMobility\" After placing this module in your simulation you need to set up the paths to the SITL simulators for each vehicle type supported. Currently you have to set up the copterSimulatorPath , planeSimulatorPath and roverSimulatorPath parameters. These are the paths to the files you have downloaded through out the installation, more specifically the path to the simulator binaries ( .elf file on windows and extensionless file on linux). For example, if you ara on windows and have placed the copter simulator in the CopterSimulator file of the root directory of your C: drive, the parameter should be set to: *.client.copterSimulatorPath = \"PATH_TO_FILE/ArduCopter.elf\" Notice the escapes characters as windows uses back-slashes in paths. INFO: If you are not using a vehicle type you can leave the path for that vehicle's simulator as an empty string. After setting this up you need to pay attention to the module's required parameters. Those can be found in the module's documentation page. Remember to pay attention if the module extends another one, as the required fields for the latter will also need to be filled. In general the parameters you need to fill when using any of the MAVSIMNET mobility models are: Parameter Type Description vehicleType int MAVLink type of vehicle that this class represents (COPTER=1, PLANE=2, ROVER=4) paramPath string Path for the parameters for this vehicle. These are the parameters you downloaded throughout the installation. Do not use parameters for a different vehicle type That is all you need to know if you plan to use this framework's existing modules with no modifications. If you plan on expanding upon it of modifying the modules there are a few more things you should be aware of. Project Structure Diagrams Project Structure Diagram MAVSIMNET architecture diagram Project Message Diagram INET offers a series of modules that control node mobility. Our objective was to create a module that was capable of simulating a very simple UAV mobility model and could react to network events. This setup allows support for a wide array of possible UAV coordination protocols. The described requirement was achieved with three modules, one resposible for communication between UAVs (communication), one for controlling the node's movement (mobility) and the last to manage the interaction between the last two (protocol). The behaviour and implementation of these modules is detailed further below. They were made in such a way that the messages exchanged between them are sufficiently generic to allow the creation of a new protocol by creating a new protocol module, with no changes to the other ones by levaraging these generic messages to carry out different procedures. The messages exchanged between them are explained further bellow and are contained on .msg files like MobilityCommand.msg , Telemetry.msg and CommunicationCommand.msg . These three modules are loaded in a .ned file. In OMNeT++ .ned files define modules that can use other modules forming a module tree. These modules can be simple (the leaves of the module tree) or a compound module that connects simple modules or other compound modules with gates. A network is a special kind of compound module that can be run as a simulation. The compound module that represents our UAVs is MobileNode.ned and MobileSensorNode.ned represents our sensors. These modules contain Communication and Mobility modules (defined in the extended module AdhocHost) and the Protocol module (defined in the file). The mobilityDrones.ned file connects all the UAVs(called quads), sensors and some other modules necessary to the simulation. ## Mobility The mobility module is responsible for controlling UAV movement and responding to requests from the protocol module to change that movement through MobilityCommand messages. It also needs to inform the procol module about the current state of the UAV's movement through Telemetry messages. As part of the module initialization the waypoint list is attached to a Telemetry message so the protocol module has access to the tour the mobile node is following. These are the messages used: MobilityCommand.msg // Commands that the mobility module should be capable of carrying out enum MobilityCommandType { // Makes the UAV reverse on its course // No params REVERSE=0; // Makes the UAV travel to a specific waypoint, following the tour pack // Param 1: Waypoint index GOTO_WAYPOINT=1; // Makes the UAV go to a specific coordinate and orient itself so it can continue the tour afterwards // Param 1: x component of the coord // Param 2: y component of the coord // Param 3: z component of the coord // Param 4: Next waypoint (Waypoint the UAV should go to after reaching the target) // Param 5: Last waypoint (Waypoint the UAV used to reach the coords) GOTO_COORDS=2; } // Message declaration containing the command Id and its parameters message MobilityCommand { MobilityCommandType commandType; double param1=-1; double param2=-1; double param3=-1; double param4=-1; double param5=-1; } Telemetry.msg // Activity that the UAV is currently carrying out enum DroneActivity { IDLE=0; NAVIGATING=1; REACHED_EDGE=2; FOLLOWING_COMMAND=3; } // Message declaration designed to share necessary UAV information with the communication module message Telemetry { int nextWaypointID=-1; int lastWaypointID=-1; int currentCommand=-1; bool isReversed=false; DroneActivity droneActivity; } The only mobility module currently implemented is DroneMobility.ned which simulates the movement of a UAV. An optional feature of the mobility module is attaching a failure generator module. They connect to the mobility module using the same gates the protocol module does and use that to send commands in order to simulate failures. This can be used to trigger random shutdowns and even to simulate energy consumption. An example of a module that simulates energy consumption is the SimpleEnergyConsumption, a parametrized component to simulate consumption and battery capacity. It sends RETURN_TO_HOME messages to the vehicle when the UAV's battery reaches a certain threshold and shuts it down when the battery is depleted. Configuring the use of failures for your mobile nodes is easy. The .failures[] array can be used to add as many failure generators as needed and the number of failures can be configured using the .numFailures option. ```python # Configuring two types of failures for quads[0] .quads[0].numFailures = 2 # Two failures .quads[0].failures[0].typename=\"SimpleConsumptionEnergy\" # The first one will use a simple energy consumption module .quads[0].failures[0].batteryCapacity = 5000mAh .quads[0].failures[0].batteryRTLThreshold = 4500mAh .quads[0].failures[0].batteryConsumption = 10A .quads[0].failures[0].rechargeDuration = 5s .quads[1].failures[1].typename=\"RanfomFailureGenerator\" # The second will use a random failure generator .quads[1].failures[1].failureStart = 10s .quads[1].failures[1].failureMininumInterval = 40s .quads[1].failures[1].failureChance = 0.001 ``` Heres a diagram illustrating the functionality of some of these models: ## Communication INET provides built in support for the simulation of real communications protocols and the communication module takes advantage of this to simulate communication between nodes. It also has to inform the protocol module of the messages being recieved by sharing the messages themselves and listen to orders from the protocol module through CommunicationCommands. Here are the messages used: CommunicationCommand.msg ```C++ enum CommunicationCommandType { // Sets the payload that the communication module sends SET_PAYLOAD=0; // Sets the target of the communication message (null means broadcast) SET_TARGET=1; } // Message declaration for the communication command message CommunicationCommand { CommunicationCommandType commandType; // Template for the SET_PAYLOAD message type (message that the communication module should send) inet::FieldsChunk *payloadTemplate; // Target for the set target command string target; } ``` The message module has several implementations. The base folder contains several base implementations for possible communication modules, these files contain functions that interface with INET's communication capabilities but don't implement interaction with any other module. These files were used as base for the implementation of the communication modules. The following files are the implementations used in the simulations: * UdpMobileNodeCommunicationApp.ned Manages the communication between mobile nodes and between mobile nodes and sensors. UdpSensorCommunicationApp.ned Manages communication between sensors and mobile nodes. Protocol The protocol module manages the interaction between the movement and communication of the mobile nodes. It makes use of the messages provided by it's two sibling modules to create node interaction strategies. It mostly reacts to messages it recieves from those modules and determines which orders to give them to achieve the desired result. It gathers information about the current state of the simulation by analysing Telemetry messages recieved from the Mobility module and Packets forwarded to it by the Communication module. An important task it performs is the definition of the message sent by the Communication module. These messages will be sent to other nodes that will themselves handle them. The messages are inserted into IP Packages as payload. They can have different formats depending on the protocol being implemented. Here is the DadcaMessage.msg used by the Dadca protocol, for example. DadcaMessage.msg enum DadcaMessageType { HEARTBEAT = 0; PAIR_REQUEST = 1; PAIR_CONFIRM = 2; BEARER = 3; } class DadcaMessage extends FieldsChunk { chunkLength = B(34); // Fixed chunk length int sourceID = -1; // ID of the message's source int destinationID = -1; // ID of the message's destination int nextWaypointID = -1; // ID of the next waypoint int lastWaypointID = -1; // ID of the last waypoint int dataLength = 5; // Length of the imaginary data being carried in the message int leftNeighbours = 0; // Neighbours to the left of the UAV int rightNeighbours = 0; // Neighbours to the right of the UAV bool reversed = false; // Reverse flag which indicates the current direction the UAV is travelling in DadcaMessageType messageType = HEARTBEAT; // Type of message } Protocols implement an IProtocol interface and extend CommunicationProtocolBase.ned which provides useful stub functions to use when implementing protocols. These functions are as follows: // Redirects message to the proper function virtual void handleMessage(cMessage *msg); // Handles package received from communication // This packet is a message that was sent to the UAV virtual void handlePacket(Packet *pk) {}; // Handles telemetry received from mobility // The mobility module exchanges mobility information in the form of telemetry virtual void handleTelemetry(Telemetry *telemetry) {}; // Sends command to mobility virtual void sendCommand(MobilityCommand *order); // Sends command to communication virtual void sendCommand(CommunicationCommand *order); // Sets a timeout virtual void initiateTimeout(simtime_t duration); // Checks if the module is timed out virtual bool isTimedout(); These are the currently implemented protocols: ZigZagProtocol.ned and ZigZagProtocolSensor.ned These files implement the mobile node and the sensor side of the ZigZag protocol. This prococol manages a group of UAVs folowwing a set path passing above several sensors from where they pick up imaginary data from those sensors. The UAVs also interact with each other sending several messages to coordinate their movement. Heartbeat messages are sent on a multicast address, if these are picked up by sensors they respond with data. If they are picked up by other UAVs they initiate a communication pair by sending a Pair Request message which is them confirmed by the other UAV with a Pair Confirmation message. The UAV furthest away from the starting point of the path sends its data to the other UAV in the pair and they both reverse their movement. The objective is that over time the UAVs will each occupy an equally sized section of the course, picking up data on the way and sharing it at their section's extremities. DadcaProtocol.ned and DadcaProtocolSensor.ned This protocol is similar to the ZigZagProtocol. It also manages data collection by mobile nodes in a set path. The difference is that this method aims to speed up the process of equally spacing the UAVs in the course by implementing a more advanced movement protocol. When the Pair Confirmation message is recieved by both UAVs, confirming the pair, both UAVs take note of the number of neighours on their left (closer to the start) and their right (further from the start) and share this information with their pair. Both update their neighbour count and use it to calculate a point in the course that would represent the extremity of both their sections if their current count of neighbours is accurate. Them they both travel together to this point and revert. This behaviour is implemented with a sequence of commands that get queued on the mobility module. Development To develop new protocols, you will probably be creating new protocol modules that use the current message definitions and commands to implement new behaviour and management and data collection strategies. If the current set of commands and messages is not enough you are free to add more by modifying the message definitions and the modules so that they can properly react to these new messages. After creating a new module all you need to do to test it is modifying the desired .ini configuration to load your protocol. The protocol module is flexible and can be loaded with any implemented protocol by changing it's typename, for example: *.quads[*].protocol.typename = \"DadcaProtocol\" Developing your own communication protocol In this example we will develop a very simple protocol for our UAVs and sensors. Our UAVs will follow their waypoint paths without communication with each other, collecting data from sensors and depositing it at a central ground station. We will create sets of files ( .ned , .h and .cc ), SimpleDroneProtocol , SimpleSensorProtocol and SimpleGroundProtocol and a message declaration SimpleMessage.msg . For your convenience these files have already been created and placed in their respective folders, and the configuration file includes a launch config for this scenario. Let's start with the message. Since this protocol is very simple we will implement a message with two fields, senderType and content. SimpleMessage.msg // communication/messages/network/SimpleMessage.msg // Network messages need to extend from the FieldsChunk class or other chunk classes import inet.common.packet.chunk.Chunk; namespace inet; enum SenderType { DRONE = 0; SENSOR = 1; GROUND_STATION = 2; } class SimpleMessage extends FieldsChunk { chunkLength = B(7); // Fixed chunk length SenderType senderType; int content; } Our protocols will use this message definition to communicate with eachother. Next let's define our UAV's protocol. All it needs to do is contantly emit messages with it's current data load, listen to messages from sensors to load more data and listen to messages from the groundStation to unload. The only parameter we are defining is the timeoutDuration, we will not override the default value but it is good to have the option to increase or decrease the UAV's timeout. This timeout will be activated to prevent over-communication with the sensors and ground station. SimpleDroneProtocol.ned // communication/protocols/mobile/SimpleDroneProtocol.ned package gradys_simulations.communication.protocols.mobile; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleDroneProtocol extends CommunicationProtocolBase { parameters: @class(SimpleDroneProtocol); @signal[dataLoad](type=long); // Declaration of dataLoad signal used to track current data load that the UAV is carrying double timeoutDuration @unit(s) = default(3s); } Note that we also included a signal declaration called dataLoad. Signals are messages that bubble up the module tree and can be used to track information from modules deeper in the tree. In this case whe have configured a statistic visualizer (provided by INET) to show this signal's state on the simulation screen. omnetpp.ini *.visualizer.*.statisticVisualizer.signalName = \"dataLoad\" # Signal name *.visualizer.*.statisticVisualizer.format = \"(%v)\" *.visualizer.*.statisticVisualizer.textColor = \"red\" *.visualizer.*.statisticVisualizer.font = \"Courier New, 12px, bold\" *.visualizer.*.statisticVisualizer.opacity = 1 *.visualizer.*.statisticVisualizer.sourceFilter = \"*.quads[*].** *.groundStation.**\" Next we need to add code to our UAV module to simulate the required behaviours. Since our simple behavour only includes responding to messages from other nodes, we will only need to override the initialize and handlePacket functions. We will also create a updatePayload function that will update our message to include the current data content we collected. SimpleDroneProcol.h // communication/protocols/mobile/SimpleDroneProtocol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleDroneProtocol: public CommunicationProtocolBase { protected: simtime_t timeoutDuration; int content = 0; protected: // Performs the initialization of our module. This is a function that most OMNeT++ modules will override virtual void initialize(int stage) override; // Gets called when a packet is recieved from the communication module virtual void handlePacket(Packet *pk) override; // Helper function that updates packet content with the current collected data virtual void updatePayload(); }; } /* namespace gradys_simulations */ Our implementation of this header file is also very simple. Our initialization function will perform some startup tasks like setting our initial message and emitting a dataLoad signal so that the initial data load (0) will be displayed by the statistic visualizer described above. The UAV will increase it's content count every time it encounters another sensor message and transfer all it's data when it encounters a ground station message. Note: the par function loads the value specified in the .ned of ini files for that parameter. SimpleDroneProtocol.cc // communication/protocols/mobile/SimpleDroneProtocol.cc #include \"SimpleDroneProtocol.h\" #include \"inet/common/ModuleAccess.h\" #include \"inet/common/TagBase_m.h\" #include \"inet/common/TimeTag_m.h\" #include \"inet/common/packet/Packet.h\" namespace gradys_simulations { Define_Module(SimpleDroneProtocol); void SimpleDroneProtocol::initialize(int stage) { // Loading the parameter timeoutDuration timeoutDuration = par(\"timeoutDuration\"); // Emits the first dataLoad signal with value 0 emit(registerSignal(\"dataLoad\"), content); // Updates the payload so the UAV can start sending messages updatePayload(); } void SimpleDroneProtocol::handlePacket(Packet *pk) { // Loads the SimpleMessage from the recieved packet auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { std::cout << \"Message recieved from drone, ignoring.\" << endl; break; } case SENSOR: { if(!isTimedout()) { content += message->getContent(); // Emits signal and updates payload on data content change emit(registerSignal(\"dataLoad\"), content); updatePayload(); initiateTimeout(timeoutDuration); } break; } case GROUND_STATION: { if(content != 0 && !isTimedout()) { content = 0; // Emits signal and updates payload on data content change emit(registerSignal(\"dataLoad\"), content); updatePayload(); initiateTimeout(timeoutDuration); } break; } } } } void SimpleDroneProtocol::updatePayload() { // Creates message template with current content and correct type SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(DRONE); payload->setContent(content); // Sends command to the communication module to start using this message CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } } /* namespace gradys_simulations */ Next comes our sensor implementation. Here is the .ned file for our sensors: SimpleSensorProtocol.ned // communication/protocols/sensor/SimpleSensorProtocol.ned package gradys_simulations.communication.protocols.sensor; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleSensorProtocol extends CommunicationProtocolBase { parameters: @class(SimpleSensorProtocol); int payloadSize = default(5); } As you can see the file is very similar to the UAV's .ned file. The only big change is that our timeoutDuration parameter has been switched out for a payloadSize one. Our sensor is a passive listener so it doens't need a timeout. The payloadSize parameter defines the amound of data the sensor sends to the UAV during each communication. We will keep this at the default value 5 but you are free to change it. SimpleSensorProcol.h // communication/protocols/sensor/SimpleSensorProcol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleSensorProtocol: public CommunicationProtocolBase { protected: int payloadSize; protected: // Initialization function virtual void initialize(int stage) override; // Handles packet recieved from the UAV virtual void handlePacket(Packet *pk) override; }; } /* namespace gradys_simulations */ SimpleSensorProcotol.cc // communication/protocols/sensor/SimpleSensorProtocol.cc namespace gradys_simulations { Define_Module(SimpleSensorProtocol); void SimpleSensorProtocol::initialize(int stage) { // Loading payload size parameter payloadSize = par(\"payloadSize\"); // Sets the correct payload SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(SENSOR); payload->setContent(payloadSize); CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } void SimpleSensorProtocol::handlePacket(Packet *pk) { // Loading message from packet auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { // Sets the correct target CommunicationCommand *targetCommand = new CommunicationCommand(); targetCommand->setCommandType(CommunicationCommandType::SET_TARGET); targetCommand->setTarget(pk->getName()); sendCommand(targetCommand); break; } case SENSOR: { break; } case GROUND_STATION: { break; } } } } /* namespace gradys_simulations */ When the sensor recieves messages from the UAVs they will set the UAV as a target (setting a target prevents the message from being broadcasted). The sensor's message is always the same, the only thing that changes is the target. The UdpSensorCommunicationApp communication module is programmed to be a passive communication module, that means that it doesn't send constant messages like the UdpMobileNodeCommunicationApp , it only sends messages when a new target or payload is set. Last is the ground station. The ground station needs to listen to messages from UAVs and collect the data they are carrying and send a confirmation message back to the so they can empty their data load. SimpleGroundProtocol.ned // communication/protocols/ground/SimpleGroundProtocol.ned package gradys_simulations.communication.protocols.ground; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleGroundProtocol extends CommunicationProtocolBase { parameters: @class(SimpleGroundProtocol); @signal[dataLoad](type=long); // Declaration of dataLoad signal used to track current data load that the UAV is carrying } The ground station itself needs no parameters but it does need the dataLoad signal declaration so that it can properly display it's collected data. The implementation bellow is very similar to the sensor's code, the only thing changing is the message sender type. SimpleGroundProtocol.h // communication/protocols/ground/SimpleGroundProtocol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleGroundProtocol: public CommunicationProtocolBase { protected: int content = 0; protected: virtual void initialize(int stage) override; virtual void handlePacket(Packet *pk) override; }; } /* namespace gradys_simulations */ SimpleGroundProtocol.cc // communication/protocols/ground/SimpleGroundProtocol.cc namespace gradys_simulations { Define_Module(SimpleGroundProtocol); void SimpleGroundProtocol::initialize(int stage) { emit(registerSignal(\"dataLoad\"), content); // Sets the correct payload SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(GROUND_STATION); payload->setContent(0); CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } void SimpleGroundProtocol::handlePacket(Packet *pk) { auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { content += message->getContent(); // Emits signal on data content change emit(registerSignal(\"dataLoad\"), content); // Sets the correct target CommunicationCommand *targetCommand = new CommunicationCommand(); targetCommand->setCommandType(CommunicationCommandType::SET_TARGET); targetCommand->setTarget(pk->getName()); sendCommand(targetCommand); break; } case SENSOR: { break; } case GROUND_STATION: { break; } } } } /* namespace gradys_simulations */ After developing all our protocols, including .ned declarations and .h and .cc implementations and creating (or using an existing) message type, all that is left is creating a launch configuration that uses our protocol. This launch configuration is already in the omnetpp.ini file as [Config Simple] [Config Simple] # Sets the description of the launch configuration. # Shown when you launch a simulation and are prompted to select the correct launch configuration. description = \"simple protocol configuration\" # UAV Configurations # This parameter is declared in the mobilityDrones.ned network and defines the number of UAVs # in the simulation. *.numUAVs = 2 # Apps are user implemented modules that extend the behaviour of INET communication modules. # In this case our app will be the communication part of our three part solution. *.quads[*].numApps = 1 # The communbication module automatically filters messages from nodes that are not included in the # destAddresses parameter. Be careful not to set the node as a destination address to itself. *.quads[0].app[0].destAddresses = \"quads[1] sensors[0] sensors[1] sensors[2] groundStation\" *.quads[1].app[0].destAddresses = \"quads[0] sensors[0] sensors[1] sensors[2] groundStation\" # The waypointFile parameter is declared in DroneMobility.ned and specifies the waypoint list # the UAVs will follow. *.quads[0].mobility.waypointFile = \"paths/voo_sensor1.waypoints\" *.quads[1].mobility.waypointFile = \"paths/voo_sensor2.waypoints\" # The typename parameter of the protocol specifies the filename of the protocol implementation # the protocol module will use. *.quads[*].protocol.typename = \"SimpleDroneProtocol\" # The normal() function gives us a value within 1s of 1s. This is used instead of a fixed value # because if both the quads communication apps started at 1s and had the same interval between # messages (defined by the .sendInterval parameter) they would be forever syncronized and their # messages would always interfere with each other in the medium. *.quads[0].app[*].startTime = normal(1s, 1s) *.quads[1].app[*].startTime = normal(1s, 1s) # Sensor configurations *.sensors[*].app[*].destAddresses = \"quads[0] quads[1]\" *.sensors[0..2].protocol.typename = \"SimpleSensorProtocol\" # Groundstation configurations # Setting the ground station as a sensor because it is a passive listener in this config *.groundStation.app[0].typename = \"UdpSensorCommunicationApp\" *.groundStation.app[*].destAddresses = \"quads[0] quads[1]\" *.groundStation.protocol.typename = \"SimpleGroundProtocol\" *.groundStation.app[0].startTime = 0s With all that you should be able to run the simulation and after selecting \"Simple\" as a launch configuration you will see the UAVs and sensors performing the described behaviour. If you did everything right you should be seeing something like this: You can find additinal information about this developing enviroment on the OMNeT++ and INET documentations. Sometimes some classes or functions are not that well documented, in that case looking at the samples and tutorials included with INET and OMNeT++ can be a useful resource and if even that doesn't help you can easily look at INET's source code as it should be included in your workspace if you installed it correctly. MAVSIMNET Development There are two important modules in the repository's utils folder that are useful for developers. The VehicleRoutines module offers several utility functions that simplify common tasks using the MAVLink protocol. These functions generate a vector of instructions that should be queued using MAVLinkMobilityBase's queueInstructions function. The other important module is the TelemetryConditions module. As explained in the MAVLinkMobilityBase documentation messages are dispatched to the SITL instance using a message queue. This message queue moves only when the front-most message is concluded. What defines a message as concluded is a function, called a Condition, that gets called on every telemetry received. This allows a developer to define the condition that needs to be fulfilled before the next message in the queue is sent. A takeoff message could wait for the vehicle to reach a certain altutde, for example. The TelemetryRoutines module has some ready-to-use conditions for these situations. Project Configuration Running Gradys Simulations Locally Without Docker Setting Up Omnet++ and INet Locally for Running Gradys Simulations. This guide will walk you through the process of configuring Omnet++ on your local machine without the need for Docker. It covers both Linux and Windows systems and is divided into multiple sections for more clarity: 1) Installation of Omnet++ and INet Before proceeding with the official installation instructions, it's essential to make adjustments to the configure.user file located in the Omnet folder where your project will be built. These adjustments are crucial for enabling the 3D visualization used in Gradys simulations. Ensure that both WITH_OSG and WITH_OSGEARTH are set to yes. You can find an exemplary version of the configure.user file in the docker_setup folder. You can then follow the step-by-step installation procedures for Omnet++ and INet. Additionally, the simulation manual is also provided for reference: Omnet++ Installation Guide: https://doc.omnetpp.org/omnetpp/InstallGuide.pdf Omnet++ Simulation Manual: https://doc.omnetpp.org/omnetpp/manual/ 2) Importing Projects Once you have successfully installed Omnet++ and INet, you'll need to import the Gradys Simulations project and the INET project into your current workspace. You can do this as follows. Go to File -> Import -> Existing Projects into Workspace. Select the GradysSimulations Project and repeat the same for the INET Project. You can also refer to the provided screenshots for a visual guide on these steps. 3) Configuration of GradysSimulations and INet After successfully installing Omnet++ and INet, the next step is to configure your integrated development environment (IDE) for GradysSimulations and INet to effectively run your project. This configuration process involves setting up various parameters and settings tailored to the specific requirements of Gradys Simulation. Configuration Gradys Simulation To run the Gradys Simulation project smoothly, several configurations must be in place, particularly regarding how the program locates includes for Python, JSON, Pybind, and Pybind JSON. These settings can be found within the \"Paths and Symbols\" configuration. You can access this configuration as follows: Right Click on your project -> Properties -> C/C++ General -> Paths and Symbols. Within the \"Paths and Symbols\" configuration, you will find three language tabs: Assembly, C, and C++. Since our imported projects only employ C++ for JSON, Pybind, and Pybind_JSON, you need to focus on the C++ tab. All other tabs should primarily include the project itself. For a visual guide on these steps follow step i, ii. In addition to that, the project's Makemake needs to be configured. In the Target tab it's important to specify a custom target name since the project otherwise has build problems. For the Compile it is important that all projects that are relative to the makefile and are used are imported. This means /mavlink, /json, /pybind11, /pybind11_json, /gradys_simulations, . . For the Linking tab it's important that additional libraries such as pthread and the path to the libpython are included. For a visual guide on these steps follow step iii. Last but not least we have to ensure that the python installation is correctly configured and we have our simulator package properly installed. For this we have to go into the PyDev - Interpreter / Grammar Settings and select our installed python environment in which we want to install the simulator package. In our case we have set up a new python installation with pyenv.One way of doing this is shown here: https://github.com/pyenv/pyenv. Afterwards we go into the python project and can run pip install . in the root of the project. Open Configuration Menu Configure Paths and Symbols Configure Project Makemake Configure Python Environment Configuration INet For the configuration of INet only the Project Features of the Omnet++ have to be adjusted. In particular we need to enable 3D Visualization. This is necessary so that we can have a nice visual presentation of our drones and sensors in Omnet++. Running Gradys Simulations in Docker This guide works under Linux and Windows (WSL2). In the following it is explained how to setup the Docker Container and open to Omnet++ IDE to run the GradysSimulations with Python and SITL extension. Additionally it will explain how to build the docker container on your own and how to configure it. 1) Running the docker container using the existing image: - Install Docker on your machine - Open a Terminal (on Windows use WSL2) - Run the following commands before pulling & running the docker image: > export DISPLAY=:0.0 > xhost +local:docker - Pull and run the docker image from docker hub > docker run -ti -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix kamysek/gradys-simulations bash - After the docker image is pulled and a bash opens, run the following command to start the preconfigured Omnet++ with Python extension > omnetpp 2) For building the docker image on your own machine use the following steps: NOTE: In case changes to the code base were made and they required changes in the omnet setting e.g. updating paths / including imports. Make sure that those are also updated in the docker_setup folder. This folder contains basic ide settings as well as metadata information Install Docker on your machine Open a Terminal (on Windows use WSL2) in the directory of the Dockerfile Run the following command to build the image > docker build --build-arg OMNETPP_VERSION=6.0.1 --build-arg INET_VERSION=4.5 . After the image is successfully built check the image id and run the container > docker image ls > export DISPLAY=:0.0 > xhost +local:docker > docker run -ti -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix [IMAGE_ID] bash Now that the container is opened start omnetpp with the following command > omnetpp Afterwards select the workspace folder and make it your default. The folder is called workspace and is located in the home directory Now that this is done make sure the correct INET project settings are enabled Afterwards you can run any showcase to experiment with omnetpp","title":"Gradys Simulations"},{"location":"#gradys-simulations","text":"Simulations from Project GrADyS on OMNET++ and INET framework","title":"Gradys Simulations"},{"location":"#introduction","text":"This is a repository for the simulation framework developed for the GrADyS project. This framework allows the simulation of interconnected network nodes and the implementation of UAV swarms and sensor coordination strategies with the objective of managing these autonomous UAV swarms to collect sensor data on the field autonomously and efficiently. Gradys Simulations MAVSIMNET a simulation framework for the OMNET++ discrete event simulator based on Ardupilot's Software In The Loop (SITL) simulator. It allows you to enrich OMNeT++ and INET's simulations with realistic mobility models for the mobile nodes in your network. It works by spawning SITL instances that provide a physical simulation of the vehicle's behaviour and connecting them to the mobility classes in your simulation. A user can transparently use these mobility modules without worrying about the details of the communication and messages being exchanged between the network simulator and the SITL instances and a developer can use the strong interface provided in the project's base mobility class to implement his own mobility modules.","title":"Introduction"},{"location":"#installation","text":"There are two ways to install and use Gradys-Sim. The first one is to download the provided virtual applience which you can import into any virtual machine software that supports the .ova file format. The second one it to install direcly into your machine","title":"Installation"},{"location":"#1-virtualization","text":"Just download the virtual applience file (.ova) from this link and import it into any virtual machine software that supports the .ova file format. There should be a user called \"gradys\" with password \"gradys\" already created on imported virtual machine. Oracle's VirtualBox is recommended. Previous versions of this image: OMNeT++ 5.6.2","title":"1. Virtualization"},{"location":"#2-local-installation","text":"In order to run the simulations and use the components in this repository you need to have both OMNeT++ and the INET framework installed. Version 6.0.1 of OMNeT++ is required, to install it just follow these instructions . INET version 4.5.0 is also required, when first opening the OMNeT++ IDE you should be prompted with the option to install INET and all you need to do is accept it but if you need help check out the installation instructions . After installing both OMNeT++ and INET you should be able to clone the repository to your active OMNeT++ IDE workspace. To do this select File > Import... then open the \"git\" section and select \"Projects from git\" then \"Clone Uri\". After that just fill in the URL for this repository and finish the process following the displayed instructions. Make sure you have INET installed in your workspace and that it is selected as project reference. If you see a directory named inet , inet4.5 in your workspace INET is installed and you only need to check if its also selected for the gradys-simulations project. This can be done the following way: Right Click on gradys-simulations project -> Properties -> Project References. Make sure INET is selected here. The sitl file for advanced mobility simulations are already included in the project. However if you would like to use newer versions, download the compiled SITL simulator for each vehicle type you want to use. Save the paths to these files as you will need them later. Binaries can be found on ardupilot's firmware website . These are the binaries for the most common platforms and supported vehicles: Vehicle Windows Linux Copter Link Link Plane Link Link Rover Link Link The same applies to the parameter files for the vehilce types. There are already some defaults included in the project however if you would like to use different or check for the newest version do the following: Write or download parameter files for the vehicle types you want to use. Save the paths to these files as you will need them later. We recommend donwloading the default parameter files from here: Vehicle Location Copter Link Plane Link Rover Link WARNING: You will need to modify the .ini file for the simulations and any other that you run to include your SITL installation paths and parameter file paths for each type of vehicle that you want to use.","title":"2. Local Installation"},{"location":"#usage","text":"OMNeT++ simulations are initialized by .ini files. The already provided omnetpp.ini files in the showcases contain some launch configurations for Wifi only communication and shared Wifi and MAM communication, each with configs for one to four UAVs. Launch configurations are defined in the same .ini file denoted by the [Config SOME_NAME]. The [Config Wifi] and [Config MAM] configs are base configs for the other ones and should not be ran. All confiruation files are set to load the simulations on our field test location in Brasilia. If you want to change this you will have to chage these parameters: # Scene's coordinates *.coordinateSystem.sceneLongitude = -47.926634deg *.coordinateSystem.sceneLatitude = -15.840075deg *.coordinateSystem.sceneHeading = 90deg # Vehicle's home coordinates *.quads[*].mobility.homeLatitude = -15.840068deg *.quads[*].mobility.homeLongitude = -47.926633deg # Ground Station's coordinates *.groundStation.mobility.initialLatitude = -15.840068deg *.groundStation.mobility.initialLongitude = -47.926633deg # Sensor's coordinates *.sensors[0].mobility.initialLatitude = -15.84245230deg *.sensors[0].mobility.initialLongitude = -47.92948720deg Aditionally, the quads follow a series of waypoints specified in a waypoint file. You will also need to change these to reasonable waypoints on your simulation's location. Example of a waypoint file: # Numers 9,10 and 11 specify latitude, logitude and altitude QGC WPL 110 0 1 0 16 0 0 0 0 -15.840075 -47.926634 0 1 1 0 3 22 0.00000000 0.00000000 0.00000000 0.00000000 -15.84008500 -47.92663560 20.000000 1 2 0 3 16 0.00000000 0.00000000 0.00000000 0.00000000 -15.84011710 -47.92712550 20.000000 1 3 0 3 16 5.00000000 0.00000000 0.00000000 0.00000000 -15.84019450 -47.92777060 20.000000 1 4 0 3 16 0.00000000 0.00000000 0.00000000 0.00000000 -15.84029000 -47.92860750 20.000000 1 5 0 3 16 5.00000000 0.00000000 0.00000000 0.00000000 -15.84019500 -47.92777060 20.000000 1 6 0 0 177 2.00000000 4.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.000000 1 7 0 0 20 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.00000000 0.000000 1 Recently some more showcases were added. They were created to test and measure the results of a simple simulation with a single drone collecting data from a couple of sensors. The simplicity of these simulations is intentional as it allows us to measure the effect that different parameters have on the collection rate and range of the vehicle. The configs set up simulation campaigns that help us figure out the parameters we should use to better reflect the numbers we observe on real-life experiments. To aid us in interpreting this data we implemented data reporting to the modules used in these configs. When the parameter campaigns run they generate several .vec and other OMNeT++ statistical files. By using OMNeT++'s built in data analysis tools we can extrant information from these runs. To learn more about how to use these files to generate visualizations using the OMNeT++ IDE, check it's User Guida . Here are some examples: Launch configurations dictate the parameters of your simulation and you can change omnetpp.ini to suit your necessities. Here are some of the more important parameters that you can try switching yourself: The number of UAVs and sensors in the simulation: *.numUAVs = 2 // Initializes the *.quad[] array with 2 UAVs *.numSensors = 8 // Initializes the *.sensors[] array with 8 sensors Some UAV (called quads in this file) parameters: // The protocol the UAV will follow (protocols explained further bellow) // Change this to test other protocols like \"ZigzagProtocol\" *.quads[*].protocol.typename = \"DadcaProtocol\" // The UAV's destination addresses (nodes it talks to and recieves messages from) *.quads[0].app[0].destAddresses = \"quads[1] sensors[0] sensors[1] sensors[2] groundStation\" // Start time for the UAV's communication and mobility modules // Change this to expertiment with different start timings *.quads[1].app[*].startTime = normal(40s, 1s) // Here the normal function gives a value 1s within 40s *.quads[1].mobility.startTime = 40s // The waypoint file the UAV should follow *.quads[*].mobility.waypointFile = \"paths/voo_ar.waypoints\" Some sensor parameters: // The sensor's destination addresses *.sensors[*].app[0].destAddresses = \"quads[0] quads[1]\" // The protocol the sensor should follow *.sensors[0..2].protocol.typename = \"DadcaProtocolSensor\" // The sensor's position coordinates *.sensors[0].mobility.initialLatitude = -15.84245230deg *.sensors[0].mobility.initialLongitude = -47.92948720deg To run a simulation simply select one of the .ini files in the showcases and use the OMNeT++ IDE Run option. After the GUI opens select the desired launch configuration and press play on the simulation.","title":"Usage"},{"location":"#for-more-realistic-simulations","text":"The mobility modules available in this framework are instances of INET mobility modules. If you do not know what those are or how to use them you can check INET's documentation . There you will learn how to set up a simulation environment, populate it with nodes and set them up with mobility modules . After your simulation is set up there is only a couple things you need to worry about. A very important thing to take note of is that your simulation has to use INET's Real Time Scheduler. This guarantees that the SITL instances and OMNET++ are syncronized. You can set this up in your .ini file with this line: scheduler-class = \"inet::RealTimeScheduler\" Using the available mobility modules is as simple as setting your node's mobility module. You can do this with the following command, using the RandomWaypointMobility module as an example: *.client[*].mobility.typename = \"MAVLinkRandomWaypointMobility\" After placing this module in your simulation you need to set up the paths to the SITL simulators for each vehicle type supported. Currently you have to set up the copterSimulatorPath , planeSimulatorPath and roverSimulatorPath parameters. These are the paths to the files you have downloaded through out the installation, more specifically the path to the simulator binaries ( .elf file on windows and extensionless file on linux). For example, if you ara on windows and have placed the copter simulator in the CopterSimulator file of the root directory of your C: drive, the parameter should be set to: *.client.copterSimulatorPath = \"PATH_TO_FILE/ArduCopter.elf\" Notice the escapes characters as windows uses back-slashes in paths. INFO: If you are not using a vehicle type you can leave the path for that vehicle's simulator as an empty string. After setting this up you need to pay attention to the module's required parameters. Those can be found in the module's documentation page. Remember to pay attention if the module extends another one, as the required fields for the latter will also need to be filled. In general the parameters you need to fill when using any of the MAVSIMNET mobility models are: Parameter Type Description vehicleType int MAVLink type of vehicle that this class represents (COPTER=1, PLANE=2, ROVER=4) paramPath string Path for the parameters for this vehicle. These are the parameters you downloaded throughout the installation. Do not use parameters for a different vehicle type That is all you need to know if you plan to use this framework's existing modules with no modifications. If you plan on expanding upon it of modifying the modules there are a few more things you should be aware of.","title":"For more realistic simulations"},{"location":"#project-structure","text":"","title":"Project Structure"},{"location":"#diagrams","text":"Project Structure Diagram MAVSIMNET architecture diagram Project Message Diagram INET offers a series of modules that control node mobility. Our objective was to create a module that was capable of simulating a very simple UAV mobility model and could react to network events. This setup allows support for a wide array of possible UAV coordination protocols. The described requirement was achieved with three modules, one resposible for communication between UAVs (communication), one for controlling the node's movement (mobility) and the last to manage the interaction between the last two (protocol). The behaviour and implementation of these modules is detailed further below. They were made in such a way that the messages exchanged between them are sufficiently generic to allow the creation of a new protocol by creating a new protocol module, with no changes to the other ones by levaraging these generic messages to carry out different procedures. The messages exchanged between them are explained further bellow and are contained on .msg files like MobilityCommand.msg , Telemetry.msg and CommunicationCommand.msg . These three modules are loaded in a .ned file. In OMNeT++ .ned files define modules that can use other modules forming a module tree. These modules can be simple (the leaves of the module tree) or a compound module that connects simple modules or other compound modules with gates. A network is a special kind of compound module that can be run as a simulation. The compound module that represents our UAVs is MobileNode.ned and MobileSensorNode.ned represents our sensors. These modules contain Communication and Mobility modules (defined in the extended module AdhocHost) and the Protocol module (defined in the file). The mobilityDrones.ned file connects all the UAVs(called quads), sensors and some other modules necessary to the simulation. ## Mobility The mobility module is responsible for controlling UAV movement and responding to requests from the protocol module to change that movement through MobilityCommand messages. It also needs to inform the procol module about the current state of the UAV's movement through Telemetry messages. As part of the module initialization the waypoint list is attached to a Telemetry message so the protocol module has access to the tour the mobile node is following. These are the messages used: MobilityCommand.msg // Commands that the mobility module should be capable of carrying out enum MobilityCommandType { // Makes the UAV reverse on its course // No params REVERSE=0; // Makes the UAV travel to a specific waypoint, following the tour pack // Param 1: Waypoint index GOTO_WAYPOINT=1; // Makes the UAV go to a specific coordinate and orient itself so it can continue the tour afterwards // Param 1: x component of the coord // Param 2: y component of the coord // Param 3: z component of the coord // Param 4: Next waypoint (Waypoint the UAV should go to after reaching the target) // Param 5: Last waypoint (Waypoint the UAV used to reach the coords) GOTO_COORDS=2; } // Message declaration containing the command Id and its parameters message MobilityCommand { MobilityCommandType commandType; double param1=-1; double param2=-1; double param3=-1; double param4=-1; double param5=-1; } Telemetry.msg // Activity that the UAV is currently carrying out enum DroneActivity { IDLE=0; NAVIGATING=1; REACHED_EDGE=2; FOLLOWING_COMMAND=3; } // Message declaration designed to share necessary UAV information with the communication module message Telemetry { int nextWaypointID=-1; int lastWaypointID=-1; int currentCommand=-1; bool isReversed=false; DroneActivity droneActivity; } The only mobility module currently implemented is DroneMobility.ned which simulates the movement of a UAV. An optional feature of the mobility module is attaching a failure generator module. They connect to the mobility module using the same gates the protocol module does and use that to send commands in order to simulate failures. This can be used to trigger random shutdowns and even to simulate energy consumption. An example of a module that simulates energy consumption is the SimpleEnergyConsumption, a parametrized component to simulate consumption and battery capacity. It sends RETURN_TO_HOME messages to the vehicle when the UAV's battery reaches a certain threshold and shuts it down when the battery is depleted. Configuring the use of failures for your mobile nodes is easy. The .failures[] array can be used to add as many failure generators as needed and the number of failures can be configured using the .numFailures option. ```python # Configuring two types of failures for quads[0] .quads[0].numFailures = 2 # Two failures .quads[0].failures[0].typename=\"SimpleConsumptionEnergy\" # The first one will use a simple energy consumption module .quads[0].failures[0].batteryCapacity = 5000mAh .quads[0].failures[0].batteryRTLThreshold = 4500mAh .quads[0].failures[0].batteryConsumption = 10A .quads[0].failures[0].rechargeDuration = 5s .quads[1].failures[1].typename=\"RanfomFailureGenerator\" # The second will use a random failure generator .quads[1].failures[1].failureStart = 10s .quads[1].failures[1].failureMininumInterval = 40s .quads[1].failures[1].failureChance = 0.001 ``` Heres a diagram illustrating the functionality of some of these models: ## Communication INET provides built in support for the simulation of real communications protocols and the communication module takes advantage of this to simulate communication between nodes. It also has to inform the protocol module of the messages being recieved by sharing the messages themselves and listen to orders from the protocol module through CommunicationCommands. Here are the messages used: CommunicationCommand.msg ```C++ enum CommunicationCommandType { // Sets the payload that the communication module sends SET_PAYLOAD=0; // Sets the target of the communication message (null means broadcast) SET_TARGET=1; } // Message declaration for the communication command message CommunicationCommand { CommunicationCommandType commandType; // Template for the SET_PAYLOAD message type (message that the communication module should send) inet::FieldsChunk *payloadTemplate; // Target for the set target command string target; } ``` The message module has several implementations. The base folder contains several base implementations for possible communication modules, these files contain functions that interface with INET's communication capabilities but don't implement interaction with any other module. These files were used as base for the implementation of the communication modules. The following files are the implementations used in the simulations: * UdpMobileNodeCommunicationApp.ned Manages the communication between mobile nodes and between mobile nodes and sensors. UdpSensorCommunicationApp.ned Manages communication between sensors and mobile nodes.","title":"Diagrams"},{"location":"#protocol","text":"The protocol module manages the interaction between the movement and communication of the mobile nodes. It makes use of the messages provided by it's two sibling modules to create node interaction strategies. It mostly reacts to messages it recieves from those modules and determines which orders to give them to achieve the desired result. It gathers information about the current state of the simulation by analysing Telemetry messages recieved from the Mobility module and Packets forwarded to it by the Communication module. An important task it performs is the definition of the message sent by the Communication module. These messages will be sent to other nodes that will themselves handle them. The messages are inserted into IP Packages as payload. They can have different formats depending on the protocol being implemented. Here is the DadcaMessage.msg used by the Dadca protocol, for example. DadcaMessage.msg enum DadcaMessageType { HEARTBEAT = 0; PAIR_REQUEST = 1; PAIR_CONFIRM = 2; BEARER = 3; } class DadcaMessage extends FieldsChunk { chunkLength = B(34); // Fixed chunk length int sourceID = -1; // ID of the message's source int destinationID = -1; // ID of the message's destination int nextWaypointID = -1; // ID of the next waypoint int lastWaypointID = -1; // ID of the last waypoint int dataLength = 5; // Length of the imaginary data being carried in the message int leftNeighbours = 0; // Neighbours to the left of the UAV int rightNeighbours = 0; // Neighbours to the right of the UAV bool reversed = false; // Reverse flag which indicates the current direction the UAV is travelling in DadcaMessageType messageType = HEARTBEAT; // Type of message } Protocols implement an IProtocol interface and extend CommunicationProtocolBase.ned which provides useful stub functions to use when implementing protocols. These functions are as follows: // Redirects message to the proper function virtual void handleMessage(cMessage *msg); // Handles package received from communication // This packet is a message that was sent to the UAV virtual void handlePacket(Packet *pk) {}; // Handles telemetry received from mobility // The mobility module exchanges mobility information in the form of telemetry virtual void handleTelemetry(Telemetry *telemetry) {}; // Sends command to mobility virtual void sendCommand(MobilityCommand *order); // Sends command to communication virtual void sendCommand(CommunicationCommand *order); // Sets a timeout virtual void initiateTimeout(simtime_t duration); // Checks if the module is timed out virtual bool isTimedout(); These are the currently implemented protocols: ZigZagProtocol.ned and ZigZagProtocolSensor.ned These files implement the mobile node and the sensor side of the ZigZag protocol. This prococol manages a group of UAVs folowwing a set path passing above several sensors from where they pick up imaginary data from those sensors. The UAVs also interact with each other sending several messages to coordinate their movement. Heartbeat messages are sent on a multicast address, if these are picked up by sensors they respond with data. If they are picked up by other UAVs they initiate a communication pair by sending a Pair Request message which is them confirmed by the other UAV with a Pair Confirmation message. The UAV furthest away from the starting point of the path sends its data to the other UAV in the pair and they both reverse their movement. The objective is that over time the UAVs will each occupy an equally sized section of the course, picking up data on the way and sharing it at their section's extremities. DadcaProtocol.ned and DadcaProtocolSensor.ned This protocol is similar to the ZigZagProtocol. It also manages data collection by mobile nodes in a set path. The difference is that this method aims to speed up the process of equally spacing the UAVs in the course by implementing a more advanced movement protocol. When the Pair Confirmation message is recieved by both UAVs, confirming the pair, both UAVs take note of the number of neighours on their left (closer to the start) and their right (further from the start) and share this information with their pair. Both update their neighbour count and use it to calculate a point in the course that would represent the extremity of both their sections if their current count of neighbours is accurate. Them they both travel together to this point and revert. This behaviour is implemented with a sequence of commands that get queued on the mobility module.","title":"Protocol"},{"location":"#development","text":"To develop new protocols, you will probably be creating new protocol modules that use the current message definitions and commands to implement new behaviour and management and data collection strategies. If the current set of commands and messages is not enough you are free to add more by modifying the message definitions and the modules so that they can properly react to these new messages. After creating a new module all you need to do to test it is modifying the desired .ini configuration to load your protocol. The protocol module is flexible and can be loaded with any implemented protocol by changing it's typename, for example: *.quads[*].protocol.typename = \"DadcaProtocol\"","title":"Development"},{"location":"#developing-your-own-communication-protocol","text":"In this example we will develop a very simple protocol for our UAVs and sensors. Our UAVs will follow their waypoint paths without communication with each other, collecting data from sensors and depositing it at a central ground station. We will create sets of files ( .ned , .h and .cc ), SimpleDroneProtocol , SimpleSensorProtocol and SimpleGroundProtocol and a message declaration SimpleMessage.msg . For your convenience these files have already been created and placed in their respective folders, and the configuration file includes a launch config for this scenario. Let's start with the message. Since this protocol is very simple we will implement a message with two fields, senderType and content. SimpleMessage.msg // communication/messages/network/SimpleMessage.msg // Network messages need to extend from the FieldsChunk class or other chunk classes import inet.common.packet.chunk.Chunk; namespace inet; enum SenderType { DRONE = 0; SENSOR = 1; GROUND_STATION = 2; } class SimpleMessage extends FieldsChunk { chunkLength = B(7); // Fixed chunk length SenderType senderType; int content; } Our protocols will use this message definition to communicate with eachother. Next let's define our UAV's protocol. All it needs to do is contantly emit messages with it's current data load, listen to messages from sensors to load more data and listen to messages from the groundStation to unload. The only parameter we are defining is the timeoutDuration, we will not override the default value but it is good to have the option to increase or decrease the UAV's timeout. This timeout will be activated to prevent over-communication with the sensors and ground station. SimpleDroneProtocol.ned // communication/protocols/mobile/SimpleDroneProtocol.ned package gradys_simulations.communication.protocols.mobile; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleDroneProtocol extends CommunicationProtocolBase { parameters: @class(SimpleDroneProtocol); @signal[dataLoad](type=long); // Declaration of dataLoad signal used to track current data load that the UAV is carrying double timeoutDuration @unit(s) = default(3s); } Note that we also included a signal declaration called dataLoad. Signals are messages that bubble up the module tree and can be used to track information from modules deeper in the tree. In this case whe have configured a statistic visualizer (provided by INET) to show this signal's state on the simulation screen. omnetpp.ini *.visualizer.*.statisticVisualizer.signalName = \"dataLoad\" # Signal name *.visualizer.*.statisticVisualizer.format = \"(%v)\" *.visualizer.*.statisticVisualizer.textColor = \"red\" *.visualizer.*.statisticVisualizer.font = \"Courier New, 12px, bold\" *.visualizer.*.statisticVisualizer.opacity = 1 *.visualizer.*.statisticVisualizer.sourceFilter = \"*.quads[*].** *.groundStation.**\" Next we need to add code to our UAV module to simulate the required behaviours. Since our simple behavour only includes responding to messages from other nodes, we will only need to override the initialize and handlePacket functions. We will also create a updatePayload function that will update our message to include the current data content we collected. SimpleDroneProcol.h // communication/protocols/mobile/SimpleDroneProtocol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleDroneProtocol: public CommunicationProtocolBase { protected: simtime_t timeoutDuration; int content = 0; protected: // Performs the initialization of our module. This is a function that most OMNeT++ modules will override virtual void initialize(int stage) override; // Gets called when a packet is recieved from the communication module virtual void handlePacket(Packet *pk) override; // Helper function that updates packet content with the current collected data virtual void updatePayload(); }; } /* namespace gradys_simulations */ Our implementation of this header file is also very simple. Our initialization function will perform some startup tasks like setting our initial message and emitting a dataLoad signal so that the initial data load (0) will be displayed by the statistic visualizer described above. The UAV will increase it's content count every time it encounters another sensor message and transfer all it's data when it encounters a ground station message. Note: the par function loads the value specified in the .ned of ini files for that parameter. SimpleDroneProtocol.cc // communication/protocols/mobile/SimpleDroneProtocol.cc #include \"SimpleDroneProtocol.h\" #include \"inet/common/ModuleAccess.h\" #include \"inet/common/TagBase_m.h\" #include \"inet/common/TimeTag_m.h\" #include \"inet/common/packet/Packet.h\" namespace gradys_simulations { Define_Module(SimpleDroneProtocol); void SimpleDroneProtocol::initialize(int stage) { // Loading the parameter timeoutDuration timeoutDuration = par(\"timeoutDuration\"); // Emits the first dataLoad signal with value 0 emit(registerSignal(\"dataLoad\"), content); // Updates the payload so the UAV can start sending messages updatePayload(); } void SimpleDroneProtocol::handlePacket(Packet *pk) { // Loads the SimpleMessage from the recieved packet auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { std::cout << \"Message recieved from drone, ignoring.\" << endl; break; } case SENSOR: { if(!isTimedout()) { content += message->getContent(); // Emits signal and updates payload on data content change emit(registerSignal(\"dataLoad\"), content); updatePayload(); initiateTimeout(timeoutDuration); } break; } case GROUND_STATION: { if(content != 0 && !isTimedout()) { content = 0; // Emits signal and updates payload on data content change emit(registerSignal(\"dataLoad\"), content); updatePayload(); initiateTimeout(timeoutDuration); } break; } } } } void SimpleDroneProtocol::updatePayload() { // Creates message template with current content and correct type SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(DRONE); payload->setContent(content); // Sends command to the communication module to start using this message CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } } /* namespace gradys_simulations */ Next comes our sensor implementation. Here is the .ned file for our sensors: SimpleSensorProtocol.ned // communication/protocols/sensor/SimpleSensorProtocol.ned package gradys_simulations.communication.protocols.sensor; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleSensorProtocol extends CommunicationProtocolBase { parameters: @class(SimpleSensorProtocol); int payloadSize = default(5); } As you can see the file is very similar to the UAV's .ned file. The only big change is that our timeoutDuration parameter has been switched out for a payloadSize one. Our sensor is a passive listener so it doens't need a timeout. The payloadSize parameter defines the amound of data the sensor sends to the UAV during each communication. We will keep this at the default value 5 but you are free to change it. SimpleSensorProcol.h // communication/protocols/sensor/SimpleSensorProcol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleSensorProtocol: public CommunicationProtocolBase { protected: int payloadSize; protected: // Initialization function virtual void initialize(int stage) override; // Handles packet recieved from the UAV virtual void handlePacket(Packet *pk) override; }; } /* namespace gradys_simulations */ SimpleSensorProcotol.cc // communication/protocols/sensor/SimpleSensorProtocol.cc namespace gradys_simulations { Define_Module(SimpleSensorProtocol); void SimpleSensorProtocol::initialize(int stage) { // Loading payload size parameter payloadSize = par(\"payloadSize\"); // Sets the correct payload SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(SENSOR); payload->setContent(payloadSize); CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } void SimpleSensorProtocol::handlePacket(Packet *pk) { // Loading message from packet auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { // Sets the correct target CommunicationCommand *targetCommand = new CommunicationCommand(); targetCommand->setCommandType(CommunicationCommandType::SET_TARGET); targetCommand->setTarget(pk->getName()); sendCommand(targetCommand); break; } case SENSOR: { break; } case GROUND_STATION: { break; } } } } /* namespace gradys_simulations */ When the sensor recieves messages from the UAVs they will set the UAV as a target (setting a target prevents the message from being broadcasted). The sensor's message is always the same, the only thing that changes is the target. The UdpSensorCommunicationApp communication module is programmed to be a passive communication module, that means that it doesn't send constant messages like the UdpMobileNodeCommunicationApp , it only sends messages when a new target or payload is set. Last is the ground station. The ground station needs to listen to messages from UAVs and collect the data they are carrying and send a confirmation message back to the so they can empty their data load. SimpleGroundProtocol.ned // communication/protocols/ground/SimpleGroundProtocol.ned package gradys_simulations.communication.protocols.ground; import gradys_simulations.communication.protocols.base.CommunicationProtocolBase; simple SimpleGroundProtocol extends CommunicationProtocolBase { parameters: @class(SimpleGroundProtocol); @signal[dataLoad](type=long); // Declaration of dataLoad signal used to track current data load that the UAV is carrying } The ground station itself needs no parameters but it does need the dataLoad signal declaration so that it can properly display it's collected data. The implementation bellow is very similar to the sensor's code, the only thing changing is the message sender type. SimpleGroundProtocol.h // communication/protocols/ground/SimpleGroundProtocol.h #include <omnetpp.h> #include \"../base/CommunicationProtocolBase.h\" #include \"../../messages/network/SimpleMessage_m.h\" namespace gradys_simulations { class SimpleGroundProtocol: public CommunicationProtocolBase { protected: int content = 0; protected: virtual void initialize(int stage) override; virtual void handlePacket(Packet *pk) override; }; } /* namespace gradys_simulations */ SimpleGroundProtocol.cc // communication/protocols/ground/SimpleGroundProtocol.cc namespace gradys_simulations { Define_Module(SimpleGroundProtocol); void SimpleGroundProtocol::initialize(int stage) { emit(registerSignal(\"dataLoad\"), content); // Sets the correct payload SimpleMessage *payload = new SimpleMessage(); payload->addTag<CreationTimeTag>()->setCreationTime(simTime()); payload->setSenderType(GROUND_STATION); payload->setContent(0); CommunicationCommand *command = new CommunicationCommand(); command->setCommandType(CommunicationCommandType::SET_PAYLOAD); command->setPayloadTemplate(payload); sendCommand(command); } void SimpleGroundProtocol::handlePacket(Packet *pk) { auto message = pk->peekAtBack<SimpleMessage>(B(7), 1); if(message != nullptr) { switch(message->getSenderType()) { case DRONE: { content += message->getContent(); // Emits signal on data content change emit(registerSignal(\"dataLoad\"), content); // Sets the correct target CommunicationCommand *targetCommand = new CommunicationCommand(); targetCommand->setCommandType(CommunicationCommandType::SET_TARGET); targetCommand->setTarget(pk->getName()); sendCommand(targetCommand); break; } case SENSOR: { break; } case GROUND_STATION: { break; } } } } /* namespace gradys_simulations */ After developing all our protocols, including .ned declarations and .h and .cc implementations and creating (or using an existing) message type, all that is left is creating a launch configuration that uses our protocol. This launch configuration is already in the omnetpp.ini file as [Config Simple] [Config Simple] # Sets the description of the launch configuration. # Shown when you launch a simulation and are prompted to select the correct launch configuration. description = \"simple protocol configuration\" # UAV Configurations # This parameter is declared in the mobilityDrones.ned network and defines the number of UAVs # in the simulation. *.numUAVs = 2 # Apps are user implemented modules that extend the behaviour of INET communication modules. # In this case our app will be the communication part of our three part solution. *.quads[*].numApps = 1 # The communbication module automatically filters messages from nodes that are not included in the # destAddresses parameter. Be careful not to set the node as a destination address to itself. *.quads[0].app[0].destAddresses = \"quads[1] sensors[0] sensors[1] sensors[2] groundStation\" *.quads[1].app[0].destAddresses = \"quads[0] sensors[0] sensors[1] sensors[2] groundStation\" # The waypointFile parameter is declared in DroneMobility.ned and specifies the waypoint list # the UAVs will follow. *.quads[0].mobility.waypointFile = \"paths/voo_sensor1.waypoints\" *.quads[1].mobility.waypointFile = \"paths/voo_sensor2.waypoints\" # The typename parameter of the protocol specifies the filename of the protocol implementation # the protocol module will use. *.quads[*].protocol.typename = \"SimpleDroneProtocol\" # The normal() function gives us a value within 1s of 1s. This is used instead of a fixed value # because if both the quads communication apps started at 1s and had the same interval between # messages (defined by the .sendInterval parameter) they would be forever syncronized and their # messages would always interfere with each other in the medium. *.quads[0].app[*].startTime = normal(1s, 1s) *.quads[1].app[*].startTime = normal(1s, 1s) # Sensor configurations *.sensors[*].app[*].destAddresses = \"quads[0] quads[1]\" *.sensors[0..2].protocol.typename = \"SimpleSensorProtocol\" # Groundstation configurations # Setting the ground station as a sensor because it is a passive listener in this config *.groundStation.app[0].typename = \"UdpSensorCommunicationApp\" *.groundStation.app[*].destAddresses = \"quads[0] quads[1]\" *.groundStation.protocol.typename = \"SimpleGroundProtocol\" *.groundStation.app[0].startTime = 0s With all that you should be able to run the simulation and after selecting \"Simple\" as a launch configuration you will see the UAVs and sensors performing the described behaviour. If you did everything right you should be seeing something like this: You can find additinal information about this developing enviroment on the OMNeT++ and INET documentations. Sometimes some classes or functions are not that well documented, in that case looking at the samples and tutorials included with INET and OMNeT++ can be a useful resource and if even that doesn't help you can easily look at INET's source code as it should be included in your workspace if you installed it correctly.","title":"Developing your own communication protocol"},{"location":"#mavsimnet-development","text":"There are two important modules in the repository's utils folder that are useful for developers. The VehicleRoutines module offers several utility functions that simplify common tasks using the MAVLink protocol. These functions generate a vector of instructions that should be queued using MAVLinkMobilityBase's queueInstructions function. The other important module is the TelemetryConditions module. As explained in the MAVLinkMobilityBase documentation messages are dispatched to the SITL instance using a message queue. This message queue moves only when the front-most message is concluded. What defines a message as concluded is a function, called a Condition, that gets called on every telemetry received. This allows a developer to define the condition that needs to be fulfilled before the next message in the queue is sent. A takeoff message could wait for the vehicle to reach a certain altutde, for example. The TelemetryRoutines module has some ready-to-use conditions for these situations.","title":"MAVSIMNET Development"},{"location":"#project-configuration","text":"","title":"Project Configuration"},{"location":"#running-gradys-simulations-locally-without-docker","text":"Setting Up Omnet++ and INet Locally for Running Gradys Simulations. This guide will walk you through the process of configuring Omnet++ on your local machine without the need for Docker. It covers both Linux and Windows systems and is divided into multiple sections for more clarity: 1) Installation of Omnet++ and INet Before proceeding with the official installation instructions, it's essential to make adjustments to the configure.user file located in the Omnet folder where your project will be built. These adjustments are crucial for enabling the 3D visualization used in Gradys simulations. Ensure that both WITH_OSG and WITH_OSGEARTH are set to yes. You can find an exemplary version of the configure.user file in the docker_setup folder. You can then follow the step-by-step installation procedures for Omnet++ and INet. Additionally, the simulation manual is also provided for reference: Omnet++ Installation Guide: https://doc.omnetpp.org/omnetpp/InstallGuide.pdf Omnet++ Simulation Manual: https://doc.omnetpp.org/omnetpp/manual/ 2) Importing Projects Once you have successfully installed Omnet++ and INet, you'll need to import the Gradys Simulations project and the INET project into your current workspace. You can do this as follows. Go to File -> Import -> Existing Projects into Workspace. Select the GradysSimulations Project and repeat the same for the INET Project. You can also refer to the provided screenshots for a visual guide on these steps. 3) Configuration of GradysSimulations and INet After successfully installing Omnet++ and INet, the next step is to configure your integrated development environment (IDE) for GradysSimulations and INet to effectively run your project. This configuration process involves setting up various parameters and settings tailored to the specific requirements of Gradys Simulation. Configuration Gradys Simulation To run the Gradys Simulation project smoothly, several configurations must be in place, particularly regarding how the program locates includes for Python, JSON, Pybind, and Pybind JSON. These settings can be found within the \"Paths and Symbols\" configuration. You can access this configuration as follows: Right Click on your project -> Properties -> C/C++ General -> Paths and Symbols. Within the \"Paths and Symbols\" configuration, you will find three language tabs: Assembly, C, and C++. Since our imported projects only employ C++ for JSON, Pybind, and Pybind_JSON, you need to focus on the C++ tab. All other tabs should primarily include the project itself. For a visual guide on these steps follow step i, ii. In addition to that, the project's Makemake needs to be configured. In the Target tab it's important to specify a custom target name since the project otherwise has build problems. For the Compile it is important that all projects that are relative to the makefile and are used are imported. This means /mavlink, /json, /pybind11, /pybind11_json, /gradys_simulations, . . For the Linking tab it's important that additional libraries such as pthread and the path to the libpython are included. For a visual guide on these steps follow step iii. Last but not least we have to ensure that the python installation is correctly configured and we have our simulator package properly installed. For this we have to go into the PyDev - Interpreter / Grammar Settings and select our installed python environment in which we want to install the simulator package. In our case we have set up a new python installation with pyenv.One way of doing this is shown here: https://github.com/pyenv/pyenv. Afterwards we go into the python project and can run pip install . in the root of the project. Open Configuration Menu Configure Paths and Symbols Configure Project Makemake Configure Python Environment Configuration INet For the configuration of INet only the Project Features of the Omnet++ have to be adjusted. In particular we need to enable 3D Visualization. This is necessary so that we can have a nice visual presentation of our drones and sensors in Omnet++.","title":"Running Gradys Simulations Locally Without Docker"},{"location":"#running-gradys-simulations-in-docker","text":"This guide works under Linux and Windows (WSL2). In the following it is explained how to setup the Docker Container and open to Omnet++ IDE to run the GradysSimulations with Python and SITL extension. Additionally it will explain how to build the docker container on your own and how to configure it. 1) Running the docker container using the existing image: - Install Docker on your machine - Open a Terminal (on Windows use WSL2) - Run the following commands before pulling & running the docker image: > export DISPLAY=:0.0 > xhost +local:docker - Pull and run the docker image from docker hub > docker run -ti -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix kamysek/gradys-simulations bash - After the docker image is pulled and a bash opens, run the following command to start the preconfigured Omnet++ with Python extension > omnetpp 2) For building the docker image on your own machine use the following steps: NOTE: In case changes to the code base were made and they required changes in the omnet setting e.g. updating paths / including imports. Make sure that those are also updated in the docker_setup folder. This folder contains basic ide settings as well as metadata information Install Docker on your machine Open a Terminal (on Windows use WSL2) in the directory of the Dockerfile Run the following command to build the image > docker build --build-arg OMNETPP_VERSION=6.0.1 --build-arg INET_VERSION=4.5 . After the image is successfully built check the image id and run the container > docker image ls > export DISPLAY=:0.0 > xhost +local:docker > docker run -ti -e DISPLAY=$DISPLAY -v /tmp/.X11-unix:/tmp/.X11-unix [IMAGE_ID] bash Now that the container is opened start omnetpp with the following command > omnetpp Afterwards select the workspace folder and make it your default. The folder is called workspace and is located in the home directory Now that this is done make sure the correct INET project settings are enabled Afterwards you can run any showcase to experiment with omnetpp","title":"Running Gradys Simulations in Docker"},{"location":"Header/BleMeshMac/","text":"BleMeshMac Description Functions ~BleMeshMac virtual ~BleMeshMac(); initialize virtual void initialize(int) override; finish virtual void finish() override; handleLowerPacket virtual void handleLowerPacket(Packet *packet) override; handleUpperPacket virtual void handleUpperPacket(Packet *packet) override; handleSelfMessage virtual void handleSelfMessage(cMessage *) override; receiveSignal virtual void receiveSignal(cComponent *source, simsignal_t signalID, intval_t value, cObject *details) override; configureNetworkInterface virtual void configureNetworkInterface() override; fsmError void fsmError(t_mac_event event, cMessage *msg); FSM functions executeMac void executeMac(t_mac_event event, cMessage *msg); updateStatusIdle void updateStatusIdle(t_mac_event event, cMessage *msg); updateStatusBackoff void updateStatusBackoff(t_mac_event event, cMessage *msg); updateStatusCCA void updateStatusCCA(t_mac_event event, cMessage *msg); updateStatusTransmitFrame void updateStatusTransmitFrame(t_mac_event event, cMessage *msg); updateStatusWaitAck void updateStatusWaitAck(t_mac_event event, cMessage *msg); updateStatusSIFS void updateStatusSIFS(t_mac_event event, cMessage *msg); updateStatusTransmitAck void updateStatusTransmitAck(t_mac_event event, cMessage *msg); updateStatusNotIdle void updateStatusNotIdle(cMessage *msg); manageQueue void manageQueue(); updateMacState void updateMacState(t_mac_states newMacState); attachSignal void attachSignal(Packet *mac, simtime_t_cref startTime); manageMissingAck void manageMissingAck(t_mac_event event, cMessage *msg); startTimer void startTimer(t_mac_timer timer); scheduleBackoff virtual simtime_t scheduleBackoff(); decapsulate virtual void decapsulate(Packet *packet); BleMeshMac BleMeshMac(const BleMeshMac&); operator= BleMeshMac& operator=(const BleMeshMac&);","title":"BleMeshMac"},{"location":"Header/BleMeshMac/#blemeshmac","text":"","title":"BleMeshMac"},{"location":"Header/BleMeshMac/#description","text":"","title":"Description"},{"location":"Header/BleMeshMac/#functions","text":"","title":"Functions"},{"location":"Header/BleMeshMac/#blemeshmac_1","text":"virtual ~BleMeshMac();","title":"~BleMeshMac"},{"location":"Header/BleMeshMac/#initialize","text":"virtual void initialize(int) override;","title":"initialize"},{"location":"Header/BleMeshMac/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/BleMeshMac/#handlelowerpacket","text":"virtual void handleLowerPacket(Packet *packet) override;","title":"handleLowerPacket"},{"location":"Header/BleMeshMac/#handleupperpacket","text":"virtual void handleUpperPacket(Packet *packet) override;","title":"handleUpperPacket"},{"location":"Header/BleMeshMac/#handleselfmessage","text":"virtual void handleSelfMessage(cMessage *) override;","title":"handleSelfMessage"},{"location":"Header/BleMeshMac/#receivesignal","text":"virtual void receiveSignal(cComponent *source, simsignal_t signalID, intval_t value, cObject *details) override;","title":"receiveSignal"},{"location":"Header/BleMeshMac/#configurenetworkinterface","text":"virtual void configureNetworkInterface() override;","title":"configureNetworkInterface"},{"location":"Header/BleMeshMac/#fsmerror","text":"void fsmError(t_mac_event event, cMessage *msg); FSM functions","title":"fsmError"},{"location":"Header/BleMeshMac/#executemac","text":"void executeMac(t_mac_event event, cMessage *msg);","title":"executeMac"},{"location":"Header/BleMeshMac/#updatestatusidle","text":"void updateStatusIdle(t_mac_event event, cMessage *msg);","title":"updateStatusIdle"},{"location":"Header/BleMeshMac/#updatestatusbackoff","text":"void updateStatusBackoff(t_mac_event event, cMessage *msg);","title":"updateStatusBackoff"},{"location":"Header/BleMeshMac/#updatestatuscca","text":"void updateStatusCCA(t_mac_event event, cMessage *msg);","title":"updateStatusCCA"},{"location":"Header/BleMeshMac/#updatestatustransmitframe","text":"void updateStatusTransmitFrame(t_mac_event event, cMessage *msg);","title":"updateStatusTransmitFrame"},{"location":"Header/BleMeshMac/#updatestatuswaitack","text":"void updateStatusWaitAck(t_mac_event event, cMessage *msg);","title":"updateStatusWaitAck"},{"location":"Header/BleMeshMac/#updatestatussifs","text":"void updateStatusSIFS(t_mac_event event, cMessage *msg);","title":"updateStatusSIFS"},{"location":"Header/BleMeshMac/#updatestatustransmitack","text":"void updateStatusTransmitAck(t_mac_event event, cMessage *msg);","title":"updateStatusTransmitAck"},{"location":"Header/BleMeshMac/#updatestatusnotidle","text":"void updateStatusNotIdle(cMessage *msg);","title":"updateStatusNotIdle"},{"location":"Header/BleMeshMac/#managequeue","text":"void manageQueue();","title":"manageQueue"},{"location":"Header/BleMeshMac/#updatemacstate","text":"void updateMacState(t_mac_states newMacState);","title":"updateMacState"},{"location":"Header/BleMeshMac/#attachsignal","text":"void attachSignal(Packet *mac, simtime_t_cref startTime);","title":"attachSignal"},{"location":"Header/BleMeshMac/#managemissingack","text":"void manageMissingAck(t_mac_event event, cMessage *msg);","title":"manageMissingAck"},{"location":"Header/BleMeshMac/#starttimer","text":"void startTimer(t_mac_timer timer);","title":"startTimer"},{"location":"Header/BleMeshMac/#schedulebackoff","text":"virtual simtime_t scheduleBackoff();","title":"scheduleBackoff"},{"location":"Header/BleMeshMac/#decapsulate","text":"virtual void decapsulate(Packet *packet);","title":"decapsulate"},{"location":"Header/BleMeshMac/#blemeshmac_2","text":"BleMeshMac(const BleMeshMac&);","title":"BleMeshMac"},{"location":"Header/BleMeshMac/#operator","text":"BleMeshMac& operator=(const BleMeshMac&);","title":"operator="},{"location":"Header/BleMeshProtocolDissector/","text":"BleMeshProtocolDissector Description Functions dissect virtual void dissect(Packet *packet, const Protocol *protocol, ICallback& callback) const override;","title":"BleMeshProtocolDissector"},{"location":"Header/BleMeshProtocolDissector/#blemeshprotocoldissector","text":"","title":"BleMeshProtocolDissector"},{"location":"Header/BleMeshProtocolDissector/#description","text":"","title":"Description"},{"location":"Header/BleMeshProtocolDissector/#functions","text":"","title":"Functions"},{"location":"Header/BleMeshProtocolDissector/#dissect","text":"virtual void dissect(Packet *packet, const Protocol *protocol, ICallback& callback) const override;","title":"dissect"},{"location":"Header/CentralizedQLearning/","text":"CentralizedQLearning Description Functions hashValue extern void hashValue(uint32_t &value); https://stackoverflow.com/a/72073933 incorporateHash extern void incorporateHash(std::size_t& hash,uint32_t value); https://stackoverflow.com/a/72073933 hashVector extern std::size_t hashVector(const std::vector<uint32_t>& vector); virtual std::size_t operator() (const GlobalState& key) const; virtual std::size_t operator() (const QTableKey& key) const; getCurrentPosition virtual double getCurrentPosition() = 0; Gets the agent's current state getMaximumPosition virtual double getMaximumPosition() = 0; getCollectedPackets virtual uint32_t getCollectedPackets() = 0; getMaxCollectedPackets virtual uint32_t getMaxCollectedPackets() = 0; applyCommand virtual void applyCommand(const LocalControl& command) = 0; Applies a command to the agent isReady virtual bool isReady() = 0; Determines if an agent has already applied the last commant it received getAwaitingPackets virtual uint32_t getAwaitingPackets() = 0; getMaxAwaitingPackets virtual uint32_t getMaxAwaitingPackets() = 0; hasBeenVisited virtual bool hasBeenVisited() = 0; getSensorPosition virtual double getSensorPosition() = 0; getReceivedPackets virtual uint32_t getReceivedPackets() = 0; registerAgent virtual AgentInfo registerAgent(CentralizedQAgent *agent); Registers the centralized agent \"agent\" registerSensor virtual int registerSensor(CentralizedQSensor *sensor); Registers a centralized sensor \"sensor\" registerGround virtual void registerGround(CentralizedQGround *ground); Registers the ground station initialize virtual void initialize(int stage) override; OMNeT++ functions numInitStages virtual int numInitStages() const override { return 2; }; handleMessage virtual void handleMessage(cMessage *msg) override; finish virtual void finish() override; trainIfReady virtual void trainIfReady(); Training functions train virtual void train(); dispatchJointCommand virtual void dispatchJointCommand(); computeCost virtual double computeCost(const GlobalState& newState); decayEpsilon virtual void decayEpsilon(); initializeQTable virtual void initializeQTable(); Helpers exportQTable virtual void exportQTable(); importQTable virtual void importQTable(); generateRandomLocalControl virtual LocalControl generateRandomLocalControl(); generateRandomJointControl virtual JointControl generateRandomJointControl(); cMessage cMessage *trainingTimer = new cMessage(nullptr); Messages used to time the module's execution registerSignal simsignal_t trainingCostSignal = registerSignal(\"trainingCost\"); Helper variables Variables for debugging and data collection registerSignal simsignal_t epsilonSignal = registerSignal(\"epsilon\");","title":"CentralizedQLearning"},{"location":"Header/CentralizedQLearning/#centralizedqlearning","text":"","title":"CentralizedQLearning"},{"location":"Header/CentralizedQLearning/#description","text":"","title":"Description"},{"location":"Header/CentralizedQLearning/#functions","text":"","title":"Functions"},{"location":"Header/CentralizedQLearning/#hashvalue","text":"extern void hashValue(uint32_t &value); https://stackoverflow.com/a/72073933","title":"hashValue"},{"location":"Header/CentralizedQLearning/#incorporatehash","text":"extern void incorporateHash(std::size_t& hash,uint32_t value); https://stackoverflow.com/a/72073933","title":"incorporateHash"},{"location":"Header/CentralizedQLearning/#hashvector","text":"extern std::size_t hashVector(const std::vector<uint32_t>& vector);","title":"hashVector"},{"location":"Header/CentralizedQLearning/#_1","text":"virtual std::size_t operator() (const GlobalState& key) const;","title":""},{"location":"Header/CentralizedQLearning/#_2","text":"virtual std::size_t operator() (const QTableKey& key) const;","title":""},{"location":"Header/CentralizedQLearning/#getcurrentposition","text":"virtual double getCurrentPosition() = 0; Gets the agent's current state","title":"getCurrentPosition"},{"location":"Header/CentralizedQLearning/#getmaximumposition","text":"virtual double getMaximumPosition() = 0;","title":"getMaximumPosition"},{"location":"Header/CentralizedQLearning/#getcollectedpackets","text":"virtual uint32_t getCollectedPackets() = 0;","title":"getCollectedPackets"},{"location":"Header/CentralizedQLearning/#getmaxcollectedpackets","text":"virtual uint32_t getMaxCollectedPackets() = 0;","title":"getMaxCollectedPackets"},{"location":"Header/CentralizedQLearning/#applycommand","text":"virtual void applyCommand(const LocalControl& command) = 0; Applies a command to the agent","title":"applyCommand"},{"location":"Header/CentralizedQLearning/#isready","text":"virtual bool isReady() = 0; Determines if an agent has already applied the last commant it received","title":"isReady"},{"location":"Header/CentralizedQLearning/#getawaitingpackets","text":"virtual uint32_t getAwaitingPackets() = 0;","title":"getAwaitingPackets"},{"location":"Header/CentralizedQLearning/#getmaxawaitingpackets","text":"virtual uint32_t getMaxAwaitingPackets() = 0;","title":"getMaxAwaitingPackets"},{"location":"Header/CentralizedQLearning/#hasbeenvisited","text":"virtual bool hasBeenVisited() = 0;","title":"hasBeenVisited"},{"location":"Header/CentralizedQLearning/#getsensorposition","text":"virtual double getSensorPosition() = 0;","title":"getSensorPosition"},{"location":"Header/CentralizedQLearning/#getreceivedpackets","text":"virtual uint32_t getReceivedPackets() = 0;","title":"getReceivedPackets"},{"location":"Header/CentralizedQLearning/#registeragent","text":"virtual AgentInfo registerAgent(CentralizedQAgent *agent); Registers the centralized agent \"agent\"","title":"registerAgent"},{"location":"Header/CentralizedQLearning/#registersensor","text":"virtual int registerSensor(CentralizedQSensor *sensor); Registers a centralized sensor \"sensor\"","title":"registerSensor"},{"location":"Header/CentralizedQLearning/#registerground","text":"virtual void registerGround(CentralizedQGround *ground); Registers the ground station","title":"registerGround"},{"location":"Header/CentralizedQLearning/#initialize","text":"virtual void initialize(int stage) override; OMNeT++ functions","title":"initialize"},{"location":"Header/CentralizedQLearning/#numinitstages","text":"virtual int numInitStages() const override { return 2; };","title":"numInitStages"},{"location":"Header/CentralizedQLearning/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/CentralizedQLearning/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/CentralizedQLearning/#trainifready","text":"virtual void trainIfReady(); Training functions","title":"trainIfReady"},{"location":"Header/CentralizedQLearning/#train","text":"virtual void train();","title":"train"},{"location":"Header/CentralizedQLearning/#dispatchjointcommand","text":"virtual void dispatchJointCommand();","title":"dispatchJointCommand"},{"location":"Header/CentralizedQLearning/#computecost","text":"virtual double computeCost(const GlobalState& newState);","title":"computeCost"},{"location":"Header/CentralizedQLearning/#decayepsilon","text":"virtual void decayEpsilon();","title":"decayEpsilon"},{"location":"Header/CentralizedQLearning/#initializeqtable","text":"virtual void initializeQTable(); Helpers","title":"initializeQTable"},{"location":"Header/CentralizedQLearning/#exportqtable","text":"virtual void exportQTable();","title":"exportQTable"},{"location":"Header/CentralizedQLearning/#importqtable","text":"virtual void importQTable();","title":"importQTable"},{"location":"Header/CentralizedQLearning/#generaterandomlocalcontrol","text":"virtual LocalControl generateRandomLocalControl();","title":"generateRandomLocalControl"},{"location":"Header/CentralizedQLearning/#generaterandomjointcontrol","text":"virtual JointControl generateRandomJointControl();","title":"generateRandomJointControl"},{"location":"Header/CentralizedQLearning/#cmessage","text":"cMessage *trainingTimer = new cMessage(nullptr); Messages used to time the module's execution","title":"cMessage"},{"location":"Header/CentralizedQLearning/#registersignal","text":"simsignal_t trainingCostSignal = registerSignal(\"trainingCost\"); Helper variables Variables for debugging and data collection","title":"registerSignal"},{"location":"Header/CentralizedQLearning/#registersignal_1","text":"simsignal_t epsilonSignal = registerSignal(\"epsilon\");","title":"registerSignal"},{"location":"Header/CentralizedQProtocol/","text":"CentralizedQProtocol Description Functions virtual double getCurrentPosition () override { return currentDistance; }; virtual double getMaximumPosition () override { return totalMissionLength; }; getCollectedPackets uint32_t getCollectedPackets() override { return collectedPackets; }; getMaxCollectedPackets uint32_t getMaxCollectedPackets() override { return packetLimit; }; applyCommand virtual void applyCommand(const LocalControl& command) override; Applies a command to the agent cMessage cMessage* requestTimer = new cMessage(); cMessage cMessage* communicationDelayTimer = new cMessage(); initialize virtual void initialize(int stage) override; OMNeT++ and INET functions numInitStages virtual int numInitStages() const override { return 3; }; handleMessage virtual void handleMessage(cMessage *msg) override; handleTelemetry virtual void handleTelemetry(Telemetry *telemetry) override; Handles telemetry received by the mobility module and uses it to compute the mobility component of the current state. The most current telemetry message is saved. handlePacket virtual void handlePacket(Packet *pk) override; Handles packets received by the communication module. These packet can be from other UAVs, sensors and the ground station. This function implements the specific behavior triggered by the reception of these packet types. communicate virtual void communicate(int targetAgent, NodeType targetType, MessageType messageType); Helper function that sends a network messages with content specified by the function's parameters reverse virtual void reverse(); Helper function that reverses the course of the UAVs movement stop virtual void stop(); resume virtual void resume();","title":"CentralizedQProtocol"},{"location":"Header/CentralizedQProtocol/#centralizedqprotocol","text":"","title":"CentralizedQProtocol"},{"location":"Header/CentralizedQProtocol/#description","text":"","title":"Description"},{"location":"Header/CentralizedQProtocol/#functions","text":"","title":"Functions"},{"location":"Header/CentralizedQProtocol/#_1","text":"virtual double getCurrentPosition () override { return currentDistance; };","title":""},{"location":"Header/CentralizedQProtocol/#_2","text":"virtual double getMaximumPosition () override { return totalMissionLength; };","title":""},{"location":"Header/CentralizedQProtocol/#getcollectedpackets","text":"uint32_t getCollectedPackets() override { return collectedPackets; };","title":"getCollectedPackets"},{"location":"Header/CentralizedQProtocol/#getmaxcollectedpackets","text":"uint32_t getMaxCollectedPackets() override { return packetLimit; };","title":"getMaxCollectedPackets"},{"location":"Header/CentralizedQProtocol/#applycommand","text":"virtual void applyCommand(const LocalControl& command) override; Applies a command to the agent","title":"applyCommand"},{"location":"Header/CentralizedQProtocol/#cmessage","text":"cMessage* requestTimer = new cMessage();","title":"cMessage"},{"location":"Header/CentralizedQProtocol/#cmessage_1","text":"cMessage* communicationDelayTimer = new cMessage();","title":"cMessage"},{"location":"Header/CentralizedQProtocol/#initialize","text":"virtual void initialize(int stage) override; OMNeT++ and INET functions","title":"initialize"},{"location":"Header/CentralizedQProtocol/#numinitstages","text":"virtual int numInitStages() const override { return 3; };","title":"numInitStages"},{"location":"Header/CentralizedQProtocol/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/CentralizedQProtocol/#handletelemetry","text":"virtual void handleTelemetry(Telemetry *telemetry) override; Handles telemetry received by the mobility module and uses it to compute the mobility component of the current state. The most current telemetry message is saved.","title":"handleTelemetry"},{"location":"Header/CentralizedQProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Handles packets received by the communication module. These packet can be from other UAVs, sensors and the ground station. This function implements the specific behavior triggered by the reception of these packet types.","title":"handlePacket"},{"location":"Header/CentralizedQProtocol/#communicate","text":"virtual void communicate(int targetAgent, NodeType targetType, MessageType messageType); Helper function that sends a network messages with content specified by the function's parameters","title":"communicate"},{"location":"Header/CentralizedQProtocol/#reverse","text":"virtual void reverse(); Helper function that reverses the course of the UAVs movement","title":"reverse"},{"location":"Header/CentralizedQProtocol/#stop","text":"virtual void stop();","title":"stop"},{"location":"Header/CentralizedQProtocol/#resume","text":"virtual void resume();","title":"resume"},{"location":"Header/CentralizedQProtocolGround/","text":"CentralizedQProtocolGround Description Functions cMessage cMessage* dataLoggingTimer = new cMessage(); initialize virtual void initialize(int stage) override; OMNET++ methods handleMessage virtual void handleMessage(cMessage *msg) override; finish virtual void finish() override; handlePacket virtual void handlePacket(Packet *pk) override; Reacts to messages received from the commuication module","title":"CentralizedQProtocolGround"},{"location":"Header/CentralizedQProtocolGround/#centralizedqprotocolground","text":"","title":"CentralizedQProtocolGround"},{"location":"Header/CentralizedQProtocolGround/#description","text":"","title":"Description"},{"location":"Header/CentralizedQProtocolGround/#functions","text":"","title":"Functions"},{"location":"Header/CentralizedQProtocolGround/#cmessage","text":"cMessage* dataLoggingTimer = new cMessage();","title":"cMessage"},{"location":"Header/CentralizedQProtocolGround/#initialize","text":"virtual void initialize(int stage) override; OMNET++ methods","title":"initialize"},{"location":"Header/CentralizedQProtocolGround/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/CentralizedQProtocolGround/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/CentralizedQProtocolGround/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Reacts to messages received from the commuication module","title":"handlePacket"},{"location":"Header/CentralizedQProtocolSensor/","text":"CentralizedQProtocolSensor Description Functions getAwaitingPackets virtual uint32_t getAwaitingPackets() override { return awaitingPackets; }; Gets the number of awaiting packages the sensor has stored getMaxAwaitingPackets virtual uint32_t getMaxAwaitingPackets() override { return maxAwaitingPackets; }; hasBeenVisited virtual bool hasBeenVisited() override { return visited; }; getSensorPosition virtual double getSensorPosition() override { return sensorPosition; }; cMessage cMessage *generationTimer = new cMessage(); initialize virtual void initialize(int stage) override; OMNET++ methods finish virtual void finish() override; handleMessage virtual void handleMessage(cMessage *msg) override; handlePacket virtual void handlePacket(Packet *pk) override; Reacts to message received from the communication module and reacts accordingly.","title":"CentralizedQProtocolSensor"},{"location":"Header/CentralizedQProtocolSensor/#centralizedqprotocolsensor","text":"","title":"CentralizedQProtocolSensor"},{"location":"Header/CentralizedQProtocolSensor/#description","text":"","title":"Description"},{"location":"Header/CentralizedQProtocolSensor/#functions","text":"","title":"Functions"},{"location":"Header/CentralizedQProtocolSensor/#getawaitingpackets","text":"virtual uint32_t getAwaitingPackets() override { return awaitingPackets; }; Gets the number of awaiting packages the sensor has stored","title":"getAwaitingPackets"},{"location":"Header/CentralizedQProtocolSensor/#getmaxawaitingpackets","text":"virtual uint32_t getMaxAwaitingPackets() override { return maxAwaitingPackets; };","title":"getMaxAwaitingPackets"},{"location":"Header/CentralizedQProtocolSensor/#hasbeenvisited","text":"virtual bool hasBeenVisited() override { return visited; };","title":"hasBeenVisited"},{"location":"Header/CentralizedQProtocolSensor/#getsensorposition","text":"virtual double getSensorPosition() override { return sensorPosition; };","title":"getSensorPosition"},{"location":"Header/CentralizedQProtocolSensor/#cmessage","text":"cMessage *generationTimer = new cMessage();","title":"cMessage"},{"location":"Header/CentralizedQProtocolSensor/#initialize","text":"virtual void initialize(int stage) override; OMNET++ methods","title":"initialize"},{"location":"Header/CentralizedQProtocolSensor/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/CentralizedQProtocolSensor/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/CentralizedQProtocolSensor/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Reacts to message received from the communication module and reacts accordingly.","title":"handlePacket"},{"location":"Header/CommunicationProtocolBase/","text":"CommunicationProtocolBase Description Functions initialize virtual void initialize(int stage) {}; handleMessage virtual void handleMessage(cMessage *msg); Redirects message to the proper function handlePacket virtual void handlePacket(Packet *pk) {}; Handles package received from communication This packet is a message that was sent to the drone handleTelemetry virtual void handleTelemetry(Telemetry *telemetry) {}; Handles telemetry received from mobility The mobility module exchanges mobility information in the form of telemetry sendCommand virtual void sendCommand(MobilityCommand *order, int gateIndex = -1); Sends command to mobility gate. A gate index of -1 broadcasts message to all gates. sendCommand virtual void sendCommand(PythonMobilityCommand *order, int gateIndex = -1); Sends command to mobility gate. A gate index of -1 broadcasts message to all gates. sendCommand virtual void sendCommand(CommunicationCommand *order, int gateIndex = -1); Sends command to communication gate. A gate index of -1 broadcasts message to all gates. initiateTimeout virtual void initiateTimeout(simtime_t duration); Sets a timeout isTimedout virtual bool isTimedout(); Checks if the module is timed out","title":"CommunicationProtocolBase"},{"location":"Header/CommunicationProtocolBase/#communicationprotocolbase","text":"","title":"CommunicationProtocolBase"},{"location":"Header/CommunicationProtocolBase/#description","text":"","title":"Description"},{"location":"Header/CommunicationProtocolBase/#functions","text":"","title":"Functions"},{"location":"Header/CommunicationProtocolBase/#initialize","text":"virtual void initialize(int stage) {};","title":"initialize"},{"location":"Header/CommunicationProtocolBase/#handlemessage","text":"virtual void handleMessage(cMessage *msg); Redirects message to the proper function","title":"handleMessage"},{"location":"Header/CommunicationProtocolBase/#handlepacket","text":"virtual void handlePacket(Packet *pk) {}; Handles package received from communication This packet is a message that was sent to the drone","title":"handlePacket"},{"location":"Header/CommunicationProtocolBase/#handletelemetry","text":"virtual void handleTelemetry(Telemetry *telemetry) {}; Handles telemetry received from mobility The mobility module exchanges mobility information in the form of telemetry","title":"handleTelemetry"},{"location":"Header/CommunicationProtocolBase/#sendcommand","text":"virtual void sendCommand(MobilityCommand *order, int gateIndex = -1); Sends command to mobility gate. A gate index of -1 broadcasts message to all gates.","title":"sendCommand"},{"location":"Header/CommunicationProtocolBase/#sendcommand_1","text":"virtual void sendCommand(PythonMobilityCommand *order, int gateIndex = -1); Sends command to mobility gate. A gate index of -1 broadcasts message to all gates.","title":"sendCommand"},{"location":"Header/CommunicationProtocolBase/#sendcommand_2","text":"virtual void sendCommand(CommunicationCommand *order, int gateIndex = -1); Sends command to communication gate. A gate index of -1 broadcasts message to all gates.","title":"sendCommand"},{"location":"Header/CommunicationProtocolBase/#initiatetimeout","text":"virtual void initiateTimeout(simtime_t duration); Sets a timeout","title":"initiateTimeout"},{"location":"Header/CommunicationProtocolBase/#istimedout","text":"virtual bool isTimedout(); Checks if the module is timed out","title":"isTimedout"},{"location":"Header/CommunicationProtocolPythonBase/","text":"CommunicationProtocolPythonBase Description Functions initialize virtual void initialize(int stage, std::string figure); handleMessage virtual void handleMessage(cMessage *msg) override; handlePacket virtual void handlePacket(Packet *pk) override; handleTimer virtual void handleTimer(cMessage *msg); handleTelemetry virtual void handleTelemetry(Telemetry *telemetry) override; finish virtual void finish() override; updateGUI virtual void updateGUI();","title":"CommunicationProtocolPythonBase"},{"location":"Header/CommunicationProtocolPythonBase/#communicationprotocolpythonbase","text":"","title":"CommunicationProtocolPythonBase"},{"location":"Header/CommunicationProtocolPythonBase/#description","text":"","title":"Description"},{"location":"Header/CommunicationProtocolPythonBase/#functions","text":"","title":"Functions"},{"location":"Header/CommunicationProtocolPythonBase/#initialize","text":"virtual void initialize(int stage, std::string figure);","title":"initialize"},{"location":"Header/CommunicationProtocolPythonBase/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/CommunicationProtocolPythonBase/#handlepacket","text":"virtual void handlePacket(Packet *pk) override;","title":"handlePacket"},{"location":"Header/CommunicationProtocolPythonBase/#handletimer","text":"virtual void handleTimer(cMessage *msg);","title":"handleTimer"},{"location":"Header/CommunicationProtocolPythonBase/#handletelemetry","text":"virtual void handleTelemetry(Telemetry *telemetry) override;","title":"handleTelemetry"},{"location":"Header/CommunicationProtocolPythonBase/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/CommunicationProtocolPythonBase/#updategui","text":"virtual void updateGUI();","title":"updateGUI"},{"location":"Header/CustomOsgStatisticVisualizer/","text":"CustomOsgStatisticVisualizer Description // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see http://www.gnu.org/licenses/. // ifndef VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_ define VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_ include \"inet/visualizer/common/StatisticOsgVisualizer.h\" namespace gradys_simulations { Functions *createStatisticVisualization // virtual inet::visualizer::StatisticVisualizerBase::StatisticVisualization *createStatisticVisualization(cComponent *source, inet::simsignal_t signal) override; // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see http://www.gnu.org/licenses/. // ifndef VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_ define VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_ include \"inet/visualizer/common/StatisticOsgVisualizer.h\" namespace gradys_simulations { class CustomOsgStatisticVisualizer : public inet::visualizer::StatisticOsgVisualizer { protected:","title":"CustomOsgStatisticVisualizer"},{"location":"Header/CustomOsgStatisticVisualizer/#customosgstatisticvisualizer","text":"","title":"CustomOsgStatisticVisualizer"},{"location":"Header/CustomOsgStatisticVisualizer/#description","text":"// // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see http://www.gnu.org/licenses/. //","title":"Description"},{"location":"Header/CustomOsgStatisticVisualizer/#ifndef-visualization_customosgstatisticvisualizer_h_","text":"","title":"ifndef VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_"},{"location":"Header/CustomOsgStatisticVisualizer/#define-visualization_customosgstatisticvisualizer_h_","text":"","title":"define VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_"},{"location":"Header/CustomOsgStatisticVisualizer/#include-inetvisualizercommonstatisticosgvisualizerh","text":"namespace gradys_simulations {","title":"include \"inet/visualizer/common/StatisticOsgVisualizer.h\""},{"location":"Header/CustomOsgStatisticVisualizer/#functions","text":"","title":"Functions"},{"location":"Header/CustomOsgStatisticVisualizer/#createstatisticvisualization","text":"// virtual inet::visualizer::StatisticVisualizerBase::StatisticVisualization *createStatisticVisualization(cComponent *source, inet::simsignal_t signal) override; // // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU Lesser General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the // GNU Lesser General Public License for more details. // // You should have received a copy of the GNU Lesser General Public License // along with this program. If not, see http://www.gnu.org/licenses/. //","title":"*createStatisticVisualization"},{"location":"Header/CustomOsgStatisticVisualizer/#ifndef-visualization_customosgstatisticvisualizer_h__1","text":"","title":"ifndef VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_"},{"location":"Header/CustomOsgStatisticVisualizer/#define-visualization_customosgstatisticvisualizer_h__1","text":"","title":"define VISUALIZATION_CUSTOMOSGSTATISTICVISUALIZER_H_"},{"location":"Header/CustomOsgStatisticVisualizer/#include-inetvisualizercommonstatisticosgvisualizerh_1","text":"namespace gradys_simulations { class CustomOsgStatisticVisualizer : public inet::visualizer::StatisticOsgVisualizer { protected:","title":"include \"inet/visualizer/common/StatisticOsgVisualizer.h\""},{"location":"Header/DadcaProtocol/","text":"DadcaProtocol Description Functions Telemetry Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved Telemetry Telemetry lastStableTelemetry = Telemetry(); DadcaMessage DadcaMessage lastPayload = DadcaMessage(); initialize virtual void initialize(int stage) override; handleTelemetry virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override; Saves telemetry recieved by mobility handlePacket virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly isTimedout virtual bool isTimedout() override; Checks if timeout has finished and resets parameters if it has resetParameters virtual void resetParameters(); Resets parameters rendevouz virtual void rendevouz(); Sends sequence of orders that defines a rendevouz point, navigates to it and reverses updatePayload virtual void updatePayload(); Updates payload that communication will send setTarget virtual void setTarget(const char *target);","title":"DadcaProtocol"},{"location":"Header/DadcaProtocol/#dadcaprotocol","text":"","title":"DadcaProtocol"},{"location":"Header/DadcaProtocol/#description","text":"","title":"Description"},{"location":"Header/DadcaProtocol/#functions","text":"","title":"Functions"},{"location":"Header/DadcaProtocol/#telemetry","text":"Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved","title":"Telemetry"},{"location":"Header/DadcaProtocol/#telemetry_1","text":"Telemetry lastStableTelemetry = Telemetry();","title":"Telemetry"},{"location":"Header/DadcaProtocol/#dadcamessage","text":"DadcaMessage lastPayload = DadcaMessage();","title":"DadcaMessage"},{"location":"Header/DadcaProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DadcaProtocol/#handletelemetry","text":"virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override; Saves telemetry recieved by mobility","title":"handleTelemetry"},{"location":"Header/DadcaProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly","title":"handlePacket"},{"location":"Header/DadcaProtocol/#istimedout","text":"virtual bool isTimedout() override; Checks if timeout has finished and resets parameters if it has","title":"isTimedout"},{"location":"Header/DadcaProtocol/#resetparameters","text":"virtual void resetParameters(); Resets parameters","title":"resetParameters"},{"location":"Header/DadcaProtocol/#rendevouz","text":"virtual void rendevouz(); Sends sequence of orders that defines a rendevouz point, navigates to it and reverses","title":"rendevouz"},{"location":"Header/DadcaProtocol/#updatepayload","text":"virtual void updatePayload(); Updates payload that communication will send","title":"updatePayload"},{"location":"Header/DadcaProtocol/#settarget","text":"virtual void setTarget(const char *target);","title":"setTarget"},{"location":"Header/DadcaProtocolGround/","text":"DadcaProtocolGround Description Functions cMessage cMessage *dataLoggingTimer = new cMessage(); Telemetry Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved Telemetry Telemetry lastStableTelemetry = Telemetry(); DadcaMessage DadcaMessage lastPayload = DadcaMessage(); initialize virtual void initialize(int stage) override; handleMessage virtual void handleMessage(cMessage *msg) override; handleTelemetry virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override; Saves telemetry recieved by mobility handlePacket virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly isTimedout virtual bool isTimedout() override; Checks if timeout has finished and resets parameters if it has resetParameters virtual void resetParameters(); Resets parameters rendevouz virtual void rendevouz(); Sends sequence of orders that defines a rendevouz point, navigates to it and reverses updatePayload virtual void updatePayload(); Updates payload that communication will send setTarget virtual void setTarget(const char *target);","title":"DadcaProtocolGround"},{"location":"Header/DadcaProtocolGround/#dadcaprotocolground","text":"","title":"DadcaProtocolGround"},{"location":"Header/DadcaProtocolGround/#description","text":"","title":"Description"},{"location":"Header/DadcaProtocolGround/#functions","text":"","title":"Functions"},{"location":"Header/DadcaProtocolGround/#cmessage","text":"cMessage *dataLoggingTimer = new cMessage();","title":"cMessage"},{"location":"Header/DadcaProtocolGround/#telemetry","text":"Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved","title":"Telemetry"},{"location":"Header/DadcaProtocolGround/#telemetry_1","text":"Telemetry lastStableTelemetry = Telemetry();","title":"Telemetry"},{"location":"Header/DadcaProtocolGround/#dadcamessage","text":"DadcaMessage lastPayload = DadcaMessage();","title":"DadcaMessage"},{"location":"Header/DadcaProtocolGround/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DadcaProtocolGround/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/DadcaProtocolGround/#handletelemetry","text":"virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override; Saves telemetry recieved by mobility","title":"handleTelemetry"},{"location":"Header/DadcaProtocolGround/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly","title":"handlePacket"},{"location":"Header/DadcaProtocolGround/#istimedout","text":"virtual bool isTimedout() override; Checks if timeout has finished and resets parameters if it has","title":"isTimedout"},{"location":"Header/DadcaProtocolGround/#resetparameters","text":"virtual void resetParameters(); Resets parameters","title":"resetParameters"},{"location":"Header/DadcaProtocolGround/#rendevouz","text":"virtual void rendevouz(); Sends sequence of orders that defines a rendevouz point, navigates to it and reverses","title":"rendevouz"},{"location":"Header/DadcaProtocolGround/#updatepayload","text":"virtual void updatePayload(); Updates payload that communication will send","title":"updatePayload"},{"location":"Header/DadcaProtocolGround/#settarget","text":"virtual void setTarget(const char *target);","title":"setTarget"},{"location":"Header/DadcaProtocolSensor/","text":"DadcaProtocolSensor Description Functions DadcaMessage DadcaMessage lastPayload = DadcaMessage(); cMessage cMessage *generationTimer = new cMessage(); initialize virtual void initialize(int stage) override; handleMessage virtual void handleMessage(cMessage *msg) override; handleTelemetry virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override { return; }; Sensor does not recieve telemetry handlePacket virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly updatePayload virtual void updatePayload(const char *target); Updates payload that communication will send","title":"DadcaProtocolSensor"},{"location":"Header/DadcaProtocolSensor/#dadcaprotocolsensor","text":"","title":"DadcaProtocolSensor"},{"location":"Header/DadcaProtocolSensor/#description","text":"","title":"Description"},{"location":"Header/DadcaProtocolSensor/#functions","text":"","title":"Functions"},{"location":"Header/DadcaProtocolSensor/#dadcamessage","text":"DadcaMessage lastPayload = DadcaMessage();","title":"DadcaMessage"},{"location":"Header/DadcaProtocolSensor/#cmessage","text":"cMessage *generationTimer = new cMessage();","title":"cMessage"},{"location":"Header/DadcaProtocolSensor/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DadcaProtocolSensor/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/DadcaProtocolSensor/#handletelemetry","text":"virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override { return; }; Sensor does not recieve telemetry","title":"handleTelemetry"},{"location":"Header/DadcaProtocolSensor/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Reacts to message recieved and updates payload accordingly","title":"handlePacket"},{"location":"Header/DadcaProtocolSensor/#updatepayload","text":"virtual void updatePayload(const char *target); Updates payload that communication will send","title":"updatePayload"},{"location":"Header/DipoleAntennaCustom/","text":"DipoleAntennaCustom Description Functions initialize virtual void initialize(int stage) override; AntennaGain AntennaGain(const char *wireAxis, m length, m lambda, double maxGain, double minGain); computeGain virtual double computeGain(const Quaternion& direction) const override; DipoleAntennaCustom DipoleAntennaCustom(); printToStream virtual std::ostream& printToStream(std::ostream& stream, int level, int evFlags = 0) const override;","title":"DipoleAntennaCustom"},{"location":"Header/DipoleAntennaCustom/#dipoleantennacustom","text":"","title":"DipoleAntennaCustom"},{"location":"Header/DipoleAntennaCustom/#description","text":"","title":"Description"},{"location":"Header/DipoleAntennaCustom/#functions","text":"","title":"Functions"},{"location":"Header/DipoleAntennaCustom/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DipoleAntennaCustom/#antennagain","text":"AntennaGain(const char *wireAxis, m length, m lambda, double maxGain, double minGain);","title":"AntennaGain"},{"location":"Header/DipoleAntennaCustom/#computegain","text":"virtual double computeGain(const Quaternion& direction) const override;","title":"computeGain"},{"location":"Header/DipoleAntennaCustom/#dipoleantennacustom_1","text":"DipoleAntennaCustom();","title":"DipoleAntennaCustom"},{"location":"Header/DipoleAntennaCustom/#printtostream","text":"virtual std::ostream& printToStream(std::ostream& stream, int level, int evFlags = 0) const override;","title":"printToStream"},{"location":"Header/DroneMobility/","text":"DroneMobility Description Functions autocontinue autocontinue(autocontinue) { }; cMessage cMessage *telemetryTimer = new cMessage(); initialize virtual void initialize(int stage) override; setInitialPosition virtual void setInitialPosition() override; readWaypointsFromFile virtual void readWaypointsFromFile(const char *fileName) override; move virtual void move() override; Fun\ufffd\ufffdo de movimento chamada periodicamente em um self-timeout orient virtual void orient() override; Fun\ufffd\ufffdo de orienta\ufffd\ufffdo chamada periodicamente em um self-timeout fly virtual void fly(); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo plana do drone virtual void climb (double targetHeight); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo vertical do drone nextInstruction virtual void nextInstruction(); Fun\ufffd\ufffdo que pula para pr\ufffdxima instru\ufffd\ufffdo handleMessage virtual void handleMessage(cMessage *message) override; Fun\ufffd\ufffdo que captura ordens recebidas pela gate de input de ordem e trata executeCommand virtual void executeCommand(); Checks if current command has finished and performs next command in queue ~DroneMobility virtual ~DroneMobility(); createWaypoint virtual void createWaypoint(double x, double y, double z, IGeographicCoordinateSystem *coordinateSystem); sendTelemetry virtual void sendTelemetry(bool sendTour = false); Sends telemetry to the output gate instructionIndexFromWaypoint virtual int instructionIndexFromWaypoint(int waypointIndex);","title":"DroneMobility"},{"location":"Header/DroneMobility/#dronemobility","text":"","title":"DroneMobility"},{"location":"Header/DroneMobility/#description","text":"","title":"Description"},{"location":"Header/DroneMobility/#functions","text":"","title":"Functions"},{"location":"Header/DroneMobility/#autocontinue","text":"autocontinue(autocontinue) { };","title":"autocontinue"},{"location":"Header/DroneMobility/#cmessage","text":"cMessage *telemetryTimer = new cMessage();","title":"cMessage"},{"location":"Header/DroneMobility/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DroneMobility/#setinitialposition","text":"virtual void setInitialPosition() override;","title":"setInitialPosition"},{"location":"Header/DroneMobility/#readwaypointsfromfile","text":"virtual void readWaypointsFromFile(const char *fileName) override;","title":"readWaypointsFromFile"},{"location":"Header/DroneMobility/#move","text":"virtual void move() override; Fun\ufffd\ufffdo de movimento chamada periodicamente em um self-timeout","title":"move"},{"location":"Header/DroneMobility/#orient","text":"virtual void orient() override; Fun\ufffd\ufffdo de orienta\ufffd\ufffdo chamada periodicamente em um self-timeout","title":"orient"},{"location":"Header/DroneMobility/#fly","text":"virtual void fly(); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo plana do drone","title":"fly"},{"location":"Header/DroneMobility/#_1","text":"virtual void climb (double targetHeight); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo vertical do drone","title":""},{"location":"Header/DroneMobility/#nextinstruction","text":"virtual void nextInstruction(); Fun\ufffd\ufffdo que pula para pr\ufffdxima instru\ufffd\ufffdo","title":"nextInstruction"},{"location":"Header/DroneMobility/#handlemessage","text":"virtual void handleMessage(cMessage *message) override; Fun\ufffd\ufffdo que captura ordens recebidas pela gate de input de ordem e trata","title":"handleMessage"},{"location":"Header/DroneMobility/#executecommand","text":"virtual void executeCommand(); Checks if current command has finished and performs next command in queue","title":"executeCommand"},{"location":"Header/DroneMobility/#dronemobility_1","text":"virtual ~DroneMobility();","title":"~DroneMobility"},{"location":"Header/DroneMobility/#createwaypoint","text":"virtual void createWaypoint(double x, double y, double z, IGeographicCoordinateSystem *coordinateSystem);","title":"createWaypoint"},{"location":"Header/DroneMobility/#sendtelemetry","text":"virtual void sendTelemetry(bool sendTour = false); Sends telemetry to the output gate","title":"sendTelemetry"},{"location":"Header/DroneMobility/#instructionindexfromwaypoint","text":"virtual int instructionIndexFromWaypoint(int waypointIndex);","title":"instructionIndexFromWaypoint"},{"location":"Header/DroneMobilityMav/","text":"DroneMobilityMav Description Functions autocontinue autocontinue(autocontinue) { }; cMessage cMessage *telemetryTimer = new cMessage(); initialize virtual void initialize(int stage) override; readWaypointsFromFile virtual void readWaypointsFromFile(const char *fileName); move virtual void move() override; Fun\ufffd\ufffdo de movimento chamada periodicamente em um self-timeout fly virtual void fly(); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo plana do drone nextInstruction virtual void nextInstruction(); Fun\ufffd\ufffdo que pula para pr\ufffdxima instru\ufffd\ufffdo handleMessage virtual void handleMessage(cMessage *message) override; Fun\ufffd\ufffdo que captura ordens recebidas pela gate de input de ordem e trata executeCommand virtual void executeCommand(); Checks if current command has finished and performs next command in queue ~DroneMobilityMav virtual ~DroneMobilityMav(); createWaypoint virtual void createWaypoint(double x, double y, double z, IGeographicCoordinateSystem *coordinateSystem); sendTelemetry virtual void sendTelemetry(bool sendTour = false); Sends telemetry to the output gate instructionIndexFromWaypoint virtual int instructionIndexFromWaypoint(int waypointIndex);","title":"DroneMobilityMav"},{"location":"Header/DroneMobilityMav/#dronemobilitymav","text":"","title":"DroneMobilityMav"},{"location":"Header/DroneMobilityMav/#description","text":"","title":"Description"},{"location":"Header/DroneMobilityMav/#functions","text":"","title":"Functions"},{"location":"Header/DroneMobilityMav/#autocontinue","text":"autocontinue(autocontinue) { };","title":"autocontinue"},{"location":"Header/DroneMobilityMav/#cmessage","text":"cMessage *telemetryTimer = new cMessage();","title":"cMessage"},{"location":"Header/DroneMobilityMav/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/DroneMobilityMav/#readwaypointsfromfile","text":"virtual void readWaypointsFromFile(const char *fileName);","title":"readWaypointsFromFile"},{"location":"Header/DroneMobilityMav/#move","text":"virtual void move() override; Fun\ufffd\ufffdo de movimento chamada periodicamente em um self-timeout","title":"move"},{"location":"Header/DroneMobilityMav/#fly","text":"virtual void fly(); Fun\ufffd\ufffdo de voo respons\ufffdvel por definir a posi\ufffd\ufffdo plana do drone","title":"fly"},{"location":"Header/DroneMobilityMav/#nextinstruction","text":"virtual void nextInstruction(); Fun\ufffd\ufffdo que pula para pr\ufffdxima instru\ufffd\ufffdo","title":"nextInstruction"},{"location":"Header/DroneMobilityMav/#handlemessage","text":"virtual void handleMessage(cMessage *message) override; Fun\ufffd\ufffdo que captura ordens recebidas pela gate de input de ordem e trata","title":"handleMessage"},{"location":"Header/DroneMobilityMav/#executecommand","text":"virtual void executeCommand(); Checks if current command has finished and performs next command in queue","title":"executeCommand"},{"location":"Header/DroneMobilityMav/#dronemobilitymav_1","text":"virtual ~DroneMobilityMav();","title":"~DroneMobilityMav"},{"location":"Header/DroneMobilityMav/#createwaypoint","text":"virtual void createWaypoint(double x, double y, double z, IGeographicCoordinateSystem *coordinateSystem);","title":"createWaypoint"},{"location":"Header/DroneMobilityMav/#sendtelemetry","text":"virtual void sendTelemetry(bool sendTour = false); Sends telemetry to the output gate","title":"sendTelemetry"},{"location":"Header/DroneMobilityMav/#instructionindexfromwaypoint","text":"virtual int instructionIndexFromWaypoint(int waypointIndex);","title":"instructionIndexFromWaypoint"},{"location":"Header/FailureGeneratorBase/","text":"FailureGeneratorBase Description Functions initialize void initialize(int stage) {}; handleMessage void handleMessage(cMessage *msg) {};","title":"FailureGeneratorBase"},{"location":"Header/FailureGeneratorBase/#failuregeneratorbase","text":"","title":"FailureGeneratorBase"},{"location":"Header/FailureGeneratorBase/#description","text":"","title":"Description"},{"location":"Header/FailureGeneratorBase/#functions","text":"","title":"Functions"},{"location":"Header/FailureGeneratorBase/#initialize","text":"void initialize(int stage) {};","title":"initialize"},{"location":"Header/FailureGeneratorBase/#handlemessage","text":"void handleMessage(cMessage *msg) {};","title":"handleMessage"},{"location":"Header/MAVLinkFileMobility/","text":"MAVLinkFileMobility Description Functions initialize virtual void initialize(int stage) override; readMissionFromFile virtual void readMissionFromFile(); startMission virtual void startMission(); vectorToCommand virtual mavlink_command_long_t vectorToCommand(std::vector<std::string> &vector);","title":"MAVLinkFileMobility"},{"location":"Header/MAVLinkFileMobility/#mavlinkfilemobility","text":"","title":"MAVLinkFileMobility"},{"location":"Header/MAVLinkFileMobility/#description","text":"","title":"Description"},{"location":"Header/MAVLinkFileMobility/#functions","text":"","title":"Functions"},{"location":"Header/MAVLinkFileMobility/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/MAVLinkFileMobility/#readmissionfromfile","text":"virtual void readMissionFromFile();","title":"readMissionFromFile"},{"location":"Header/MAVLinkFileMobility/#startmission","text":"virtual void startMission();","title":"startMission"},{"location":"Header/MAVLinkFileMobility/#vectortocommand","text":"virtual mavlink_command_long_t vectorToCommand(std::vector<std::string> &vector);","title":"vectorToCommand"},{"location":"Header/MAVLinkMobilityBase/","text":"MAVLinkMobilityBase Description Functions ~MAVLinkMobilityBase virtual ~MAVLinkMobilityBase(); initialize virtual void initialize(int stage) override; waitUntilReady virtual void waitUntilReady(); Freezes initialization until the vehicle is pre-arm ready startSimulator virtual void startSimulator(); Starts a SITL simulator instance openSocket virtual void openSocket(); Opens the socket to the SITL instance handleMessage virtual void handleMessage(cMessage *msg) override; finish virtual void finish() override; move virtual void move() override; orient virtual void orient() override; notify virtual bool notify(int fd) override; This function is called by the RealTimeScheduler when a message is received on the open socket. It reads the message and translates it to a MAVLink message that is sent to receibeTelemetry. It should probably not be overriden. receiveTelemetry virtual void receiveTelemetry(mavlink_message_t const& message); Callback function called when a message is received from the simulated SITL instance. The default behaviour is to check if the message completes the condition of the active MAVLinkInstruction (if one exists) and to call the next MAVLinkInstruction if the current one is done. performInitialSetup virtual void performInitialSetup(); Performs initial setup on the vehicle. This includes setting update rate and setting home to current position updatePosition virtual void updatePosition(const mavlink_message_t& message); Receives telemetry and updates the vehicle's position queueMessage virtual void queueMessage(mavlink_message_t message, Condition condition = {}, simtime_t timeout = -1, int retries = 0, std::string label = \"\"); Queues instruction queueInstruction virtual void queueInstruction(std::shared_ptr<Instruction> instruction); Queues instruction queueInstructions virtual void queueInstructions(std::vector<std::shared_ptr<Instruction>> instructions); Queues list of instructions clearQueue virtual void clearQueue(); nextMessage virtual void nextMessage(); Starts first instruction in queue nextMessageIfReady virtual void nextMessageIfReady(); Gets first instruction from queue if the active instruction is completed sendActiveMessage virtual bool sendActiveMessage(); Sends the current active instruction sendMessage virtual bool sendMessage(const mavlink_message_t& message, bool shouldRetry, int &currentTries, int maxRetries); Sends a message and returns if successful mavlink_message_t getActiveMessage() { return (activeInstruction != nullptr) ? activeInstruction->message : mavlink_message_t{}; }; Condition getActiveCondition() { return (activeInstruction != nullptr) ? activeInstruction->condition : Condition{}; }; simtime_t getActiveTimeout() { return (activeInstruction != nullptr) ? activeInstruction->timeout : 0; }; int getActiveRetries() { return (activeInstruction != nullptr) ? activeInstruction->retries : 0; }; bool getActiveCompleted() { return (activeInstruction != nullptr) ? activeInstruction->completed : true; }; std::string getActiveLabel() { return (activeInstruction != nullptr) ? activeInstruction->label : \"\"; }; cMessage cMessage *timeoutMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::TIMEOUT); cMessage cMessage *heartbeatMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::HEARTBEAT); cMessage cMessage *updateMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::UPDATE);","title":"MAVLinkMobilityBase"},{"location":"Header/MAVLinkMobilityBase/#mavlinkmobilitybase","text":"","title":"MAVLinkMobilityBase"},{"location":"Header/MAVLinkMobilityBase/#description","text":"","title":"Description"},{"location":"Header/MAVLinkMobilityBase/#functions","text":"","title":"Functions"},{"location":"Header/MAVLinkMobilityBase/#mavlinkmobilitybase_1","text":"virtual ~MAVLinkMobilityBase();","title":"~MAVLinkMobilityBase"},{"location":"Header/MAVLinkMobilityBase/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/MAVLinkMobilityBase/#waituntilready","text":"virtual void waitUntilReady(); Freezes initialization until the vehicle is pre-arm ready","title":"waitUntilReady"},{"location":"Header/MAVLinkMobilityBase/#startsimulator","text":"virtual void startSimulator(); Starts a SITL simulator instance","title":"startSimulator"},{"location":"Header/MAVLinkMobilityBase/#opensocket","text":"virtual void openSocket(); Opens the socket to the SITL instance","title":"openSocket"},{"location":"Header/MAVLinkMobilityBase/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/MAVLinkMobilityBase/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/MAVLinkMobilityBase/#move","text":"virtual void move() override;","title":"move"},{"location":"Header/MAVLinkMobilityBase/#orient","text":"virtual void orient() override;","title":"orient"},{"location":"Header/MAVLinkMobilityBase/#notify","text":"virtual bool notify(int fd) override; This function is called by the RealTimeScheduler when a message is received on the open socket. It reads the message and translates it to a MAVLink message that is sent to receibeTelemetry. It should probably not be overriden.","title":"notify"},{"location":"Header/MAVLinkMobilityBase/#receivetelemetry","text":"virtual void receiveTelemetry(mavlink_message_t const& message); Callback function called when a message is received from the simulated SITL instance. The default behaviour is to check if the message completes the condition of the active MAVLinkInstruction (if one exists) and to call the next MAVLinkInstruction if the current one is done.","title":"receiveTelemetry"},{"location":"Header/MAVLinkMobilityBase/#performinitialsetup","text":"virtual void performInitialSetup(); Performs initial setup on the vehicle. This includes setting update rate and setting home to current position","title":"performInitialSetup"},{"location":"Header/MAVLinkMobilityBase/#updateposition","text":"virtual void updatePosition(const mavlink_message_t& message); Receives telemetry and updates the vehicle's position","title":"updatePosition"},{"location":"Header/MAVLinkMobilityBase/#queuemessage","text":"virtual void queueMessage(mavlink_message_t message, Condition condition = {}, simtime_t timeout = -1, int retries = 0, std::string label = \"\"); Queues instruction","title":"queueMessage"},{"location":"Header/MAVLinkMobilityBase/#queueinstruction","text":"virtual void queueInstruction(std::shared_ptr<Instruction> instruction); Queues instruction","title":"queueInstruction"},{"location":"Header/MAVLinkMobilityBase/#queueinstructions","text":"virtual void queueInstructions(std::vector<std::shared_ptr<Instruction>> instructions); Queues list of instructions","title":"queueInstructions"},{"location":"Header/MAVLinkMobilityBase/#clearqueue","text":"virtual void clearQueue();","title":"clearQueue"},{"location":"Header/MAVLinkMobilityBase/#nextmessage","text":"virtual void nextMessage(); Starts first instruction in queue","title":"nextMessage"},{"location":"Header/MAVLinkMobilityBase/#nextmessageifready","text":"virtual void nextMessageIfReady(); Gets first instruction from queue if the active instruction is completed","title":"nextMessageIfReady"},{"location":"Header/MAVLinkMobilityBase/#sendactivemessage","text":"virtual bool sendActiveMessage(); Sends the current active instruction","title":"sendActiveMessage"},{"location":"Header/MAVLinkMobilityBase/#sendmessage","text":"virtual bool sendMessage(const mavlink_message_t& message, bool shouldRetry, int &currentTries, int maxRetries); Sends a message and returns if successful","title":"sendMessage"},{"location":"Header/MAVLinkMobilityBase/#_1","text":"mavlink_message_t getActiveMessage() { return (activeInstruction != nullptr) ? activeInstruction->message : mavlink_message_t{}; };","title":""},{"location":"Header/MAVLinkMobilityBase/#_2","text":"Condition getActiveCondition() { return (activeInstruction != nullptr) ? activeInstruction->condition : Condition{}; };","title":""},{"location":"Header/MAVLinkMobilityBase/#_3","text":"simtime_t getActiveTimeout() { return (activeInstruction != nullptr) ? activeInstruction->timeout : 0; };","title":""},{"location":"Header/MAVLinkMobilityBase/#_4","text":"int getActiveRetries() { return (activeInstruction != nullptr) ? activeInstruction->retries : 0; };","title":""},{"location":"Header/MAVLinkMobilityBase/#_5","text":"bool getActiveCompleted() { return (activeInstruction != nullptr) ? activeInstruction->completed : true; };","title":""},{"location":"Header/MAVLinkMobilityBase/#_6","text":"std::string getActiveLabel() { return (activeInstruction != nullptr) ? activeInstruction->label : \"\"; };","title":""},{"location":"Header/MAVLinkMobilityBase/#cmessage","text":"cMessage *timeoutMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::TIMEOUT);","title":"cMessage"},{"location":"Header/MAVLinkMobilityBase/#cmessage_1","text":"cMessage *heartbeatMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::HEARTBEAT);","title":"cMessage"},{"location":"Header/MAVLinkMobilityBase/#cmessage_2","text":"cMessage *updateMessage = new cMessage(\"MAVLinkMobilityBaseMessage\", CommunicationSelfMessages::UPDATE);","title":"cMessage"},{"location":"Header/MAVLinkRandomWaypointMobility/","text":"MAVLinkRandomWaypointMobility Description Functions cMessage omnetpp::cMessage *waypointChangeMessage = new cMessage(\"waypointChangeMessage\"); initialize virtual void initialize(int stage) override; handleMessage virtual void handleMessage(cMessage *msg) override; finish virtual void finish() override; setTargetPosition virtual void setTargetPosition(); startMovement virtual void startMovement(); move virtual void move() override;","title":"MAVLinkRandomWaypointMobility"},{"location":"Header/MAVLinkRandomWaypointMobility/#mavlinkrandomwaypointmobility","text":"","title":"MAVLinkRandomWaypointMobility"},{"location":"Header/MAVLinkRandomWaypointMobility/#description","text":"","title":"Description"},{"location":"Header/MAVLinkRandomWaypointMobility/#functions","text":"","title":"Functions"},{"location":"Header/MAVLinkRandomWaypointMobility/#cmessage","text":"omnetpp::cMessage *waypointChangeMessage = new cMessage(\"waypointChangeMessage\");","title":"cMessage"},{"location":"Header/MAVLinkRandomWaypointMobility/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/MAVLinkRandomWaypointMobility/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/MAVLinkRandomWaypointMobility/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/MAVLinkRandomWaypointMobility/#settargetposition","text":"virtual void setTargetPosition();","title":"setTargetPosition"},{"location":"Header/MAVLinkRandomWaypointMobility/#startmovement","text":"virtual void startMovement();","title":"startMovement"},{"location":"Header/MAVLinkRandomWaypointMobility/#move","text":"virtual void move() override;","title":"move"},{"location":"Header/MamDataCollectorApp/","text":"MamDataCollectorApp Description Functions registerSignal simsignal_t dataDelaySignal = registerSignal(\"dataDelay\"); registerSignal simsignal_t uniqueDataCollectedSignal = registerSignal(\"dataLoad\"); ~MamDataCollectorApp virtual ~MamDataCollectorApp(); processPacket virtual void processPacket(Packet *msg); setSocketOptions virtual void setSocketOptions(); initialize virtual void initialize(int stage) override; handleMessageWhenUp virtual void handleMessageWhenUp(cMessage *msg) override; finish virtual void finish() override; refreshDisplay virtual void refreshDisplay() const override; socketDataArrived virtual void socketDataArrived(UdpSocket *socket, Packet *packet) override; socketErrorArrived virtual void socketErrorArrived(UdpSocket *socket, Indication *indication) override; socketClosed virtual void socketClosed(UdpSocket *socket) override; processStart virtual void processStart(); processStop virtual void processStop(); processDiscovery virtual void processDiscovery(); handleStartOperation virtual void handleStartOperation(LifecycleOperation *operation) override; handleStopOperation virtual void handleStopOperation(LifecycleOperation *operation) override; handleCrashOperation virtual void handleCrashOperation(LifecycleOperation *operation) override; sendDiscoveryPacket virtual void sendDiscoveryPacket(); sendDataAckPacket virtual void sendDataAckPacket();","title":"MamDataCollectorApp"},{"location":"Header/MamDataCollectorApp/#mamdatacollectorapp","text":"","title":"MamDataCollectorApp"},{"location":"Header/MamDataCollectorApp/#description","text":"","title":"Description"},{"location":"Header/MamDataCollectorApp/#functions","text":"","title":"Functions"},{"location":"Header/MamDataCollectorApp/#registersignal","text":"simsignal_t dataDelaySignal = registerSignal(\"dataDelay\");","title":"registerSignal"},{"location":"Header/MamDataCollectorApp/#registersignal_1","text":"simsignal_t uniqueDataCollectedSignal = registerSignal(\"dataLoad\");","title":"registerSignal"},{"location":"Header/MamDataCollectorApp/#mamdatacollectorapp_1","text":"virtual ~MamDataCollectorApp();","title":"~MamDataCollectorApp"},{"location":"Header/MamDataCollectorApp/#processpacket","text":"virtual void processPacket(Packet *msg);","title":"processPacket"},{"location":"Header/MamDataCollectorApp/#setsocketoptions","text":"virtual void setSocketOptions();","title":"setSocketOptions"},{"location":"Header/MamDataCollectorApp/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/MamDataCollectorApp/#handlemessagewhenup","text":"virtual void handleMessageWhenUp(cMessage *msg) override;","title":"handleMessageWhenUp"},{"location":"Header/MamDataCollectorApp/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/MamDataCollectorApp/#refreshdisplay","text":"virtual void refreshDisplay() const override;","title":"refreshDisplay"},{"location":"Header/MamDataCollectorApp/#socketdataarrived","text":"virtual void socketDataArrived(UdpSocket *socket, Packet *packet) override;","title":"socketDataArrived"},{"location":"Header/MamDataCollectorApp/#socketerrorarrived","text":"virtual void socketErrorArrived(UdpSocket *socket, Indication *indication) override;","title":"socketErrorArrived"},{"location":"Header/MamDataCollectorApp/#socketclosed","text":"virtual void socketClosed(UdpSocket *socket) override;","title":"socketClosed"},{"location":"Header/MamDataCollectorApp/#processstart","text":"virtual void processStart();","title":"processStart"},{"location":"Header/MamDataCollectorApp/#processstop","text":"virtual void processStop();","title":"processStop"},{"location":"Header/MamDataCollectorApp/#processdiscovery","text":"virtual void processDiscovery();","title":"processDiscovery"},{"location":"Header/MamDataCollectorApp/#handlestartoperation","text":"virtual void handleStartOperation(LifecycleOperation *operation) override;","title":"handleStartOperation"},{"location":"Header/MamDataCollectorApp/#handlestopoperation","text":"virtual void handleStopOperation(LifecycleOperation *operation) override;","title":"handleStopOperation"},{"location":"Header/MamDataCollectorApp/#handlecrashoperation","text":"virtual void handleCrashOperation(LifecycleOperation *operation) override;","title":"handleCrashOperation"},{"location":"Header/MamDataCollectorApp/#senddiscoverypacket","text":"virtual void sendDiscoveryPacket();","title":"sendDiscoveryPacket"},{"location":"Header/MamDataCollectorApp/#senddataackpacket","text":"virtual void sendDataAckPacket();","title":"sendDataAckPacket"},{"location":"Header/MamNodeApp/","text":"MamNodeApp Description Functions cComponent::registerSignal simsignal_t dataSentSignal = cComponent::registerSignal(\"dataSent\"); cComponent::registerSignal simsignal_t dataResentSignal = cComponent::registerSignal(\"dataResent\"); cComponent::registerSignal simsignal_t dataAckSignal = cComponent::registerSignal(\"dataAck\"); disGen int disGen(bool second); initialize virtual void initialize(int stage) override; handleMessageWhenUp virtual void handleMessageWhenUp(cMessage *msg) override; finish virtual void finish() override; refreshDisplay virtual void refreshDisplay() const override; chooseDestAddr virtual L3Address chooseDestAddr(); chooses random destination address processPacket virtual void processPacket(Packet *msg); setSocketOptions virtual void setSocketOptions(); processStart virtual void processStart(); processSendMyData virtual void processSendMyData(); processStop virtual void processStop(); processDiscovery virtual void processDiscovery(L3Address &src); processFoundMobileSink virtual void processFoundMobileSink(L3Address &src, int hops); processDataSend virtual void processDataSend(Packet *packet, L3Address &dest); processFriendRequest virtual void processFriendRequest(L3Address &src); processFriendOffer virtual void processFriendOffer(L3Address &src); processFriendPoll virtual void processFriendPoll(L3Address &src); processFriendUpdate virtual void processFriendUpdate(L3Address &src, int moreData); processFriendClear virtual void processFriendClear(L3Address &src); sendFriendRequest virtual void sendFriendRequest(); sendFriendEstablishedInternalMessage virtual void sendFriendEstablishedInternalMessage(); sendFriendPoll virtual void sendFriendPoll(); sendData virtual void sendData(Ptr<const BMeshPacket> data, L3Address &dest); sendDataSentAck virtual void sendDataSentAck(Packet *packet, L3Address &dest); sendMyDataToSink virtual void sendMyDataToSink(); broadcastSimpleMessage virtual void broadcastSimpleMessage(const char *msg); broadcastSimpleMessage virtual void broadcastSimpleMessage(const char *msg, int hops); sendSimpleMessage virtual void sendSimpleMessage(const char *msg, L3Address &dest, int hops); handleStartOperation virtual void handleStartOperation(LifecycleOperation *operation) override; handleStopOperation virtual void handleStopOperation(LifecycleOperation *operation) override; handleCrashOperation virtual void handleCrashOperation(LifecycleOperation *operation) override; socketDataArrived virtual void socketDataArrived(UdpSocket *socket, Packet *packet) override; socketErrorArrived virtual void socketErrorArrived(UdpSocket *socket, Indication *indication) override; socketClosed virtual void socketClosed(UdpSocket *socket) override; random_char virtual unsigned int random_char(); generate_hex virtual std::string generate_hex(const unsigned int len); ~MamNodeApp ~MamNodeApp(); generate_uuid_v4 virtual std::string generate_uuid_v4();","title":"MamNodeApp"},{"location":"Header/MamNodeApp/#mamnodeapp","text":"","title":"MamNodeApp"},{"location":"Header/MamNodeApp/#description","text":"","title":"Description"},{"location":"Header/MamNodeApp/#functions","text":"","title":"Functions"},{"location":"Header/MamNodeApp/#ccomponentregistersignal","text":"simsignal_t dataSentSignal = cComponent::registerSignal(\"dataSent\");","title":"cComponent::registerSignal"},{"location":"Header/MamNodeApp/#ccomponentregistersignal_1","text":"simsignal_t dataResentSignal = cComponent::registerSignal(\"dataResent\");","title":"cComponent::registerSignal"},{"location":"Header/MamNodeApp/#ccomponentregistersignal_2","text":"simsignal_t dataAckSignal = cComponent::registerSignal(\"dataAck\");","title":"cComponent::registerSignal"},{"location":"Header/MamNodeApp/#disgen","text":"int disGen(bool second);","title":"disGen"},{"location":"Header/MamNodeApp/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/MamNodeApp/#handlemessagewhenup","text":"virtual void handleMessageWhenUp(cMessage *msg) override;","title":"handleMessageWhenUp"},{"location":"Header/MamNodeApp/#finish","text":"virtual void finish() override;","title":"finish"},{"location":"Header/MamNodeApp/#refreshdisplay","text":"virtual void refreshDisplay() const override;","title":"refreshDisplay"},{"location":"Header/MamNodeApp/#choosedestaddr","text":"virtual L3Address chooseDestAddr(); chooses random destination address","title":"chooseDestAddr"},{"location":"Header/MamNodeApp/#processpacket","text":"virtual void processPacket(Packet *msg);","title":"processPacket"},{"location":"Header/MamNodeApp/#setsocketoptions","text":"virtual void setSocketOptions();","title":"setSocketOptions"},{"location":"Header/MamNodeApp/#processstart","text":"virtual void processStart();","title":"processStart"},{"location":"Header/MamNodeApp/#processsendmydata","text":"virtual void processSendMyData();","title":"processSendMyData"},{"location":"Header/MamNodeApp/#processstop","text":"virtual void processStop();","title":"processStop"},{"location":"Header/MamNodeApp/#processdiscovery","text":"virtual void processDiscovery(L3Address &src);","title":"processDiscovery"},{"location":"Header/MamNodeApp/#processfoundmobilesink","text":"virtual void processFoundMobileSink(L3Address &src, int hops);","title":"processFoundMobileSink"},{"location":"Header/MamNodeApp/#processdatasend","text":"virtual void processDataSend(Packet *packet, L3Address &dest);","title":"processDataSend"},{"location":"Header/MamNodeApp/#processfriendrequest","text":"virtual void processFriendRequest(L3Address &src);","title":"processFriendRequest"},{"location":"Header/MamNodeApp/#processfriendoffer","text":"virtual void processFriendOffer(L3Address &src);","title":"processFriendOffer"},{"location":"Header/MamNodeApp/#processfriendpoll","text":"virtual void processFriendPoll(L3Address &src);","title":"processFriendPoll"},{"location":"Header/MamNodeApp/#processfriendupdate","text":"virtual void processFriendUpdate(L3Address &src, int moreData);","title":"processFriendUpdate"},{"location":"Header/MamNodeApp/#processfriendclear","text":"virtual void processFriendClear(L3Address &src);","title":"processFriendClear"},{"location":"Header/MamNodeApp/#sendfriendrequest","text":"virtual void sendFriendRequest();","title":"sendFriendRequest"},{"location":"Header/MamNodeApp/#sendfriendestablishedinternalmessage","text":"virtual void sendFriendEstablishedInternalMessage();","title":"sendFriendEstablishedInternalMessage"},{"location":"Header/MamNodeApp/#sendfriendpoll","text":"virtual void sendFriendPoll();","title":"sendFriendPoll"},{"location":"Header/MamNodeApp/#senddata","text":"virtual void sendData(Ptr<const BMeshPacket> data, L3Address &dest);","title":"sendData"},{"location":"Header/MamNodeApp/#senddatasentack","text":"virtual void sendDataSentAck(Packet *packet, L3Address &dest);","title":"sendDataSentAck"},{"location":"Header/MamNodeApp/#sendmydatatosink","text":"virtual void sendMyDataToSink();","title":"sendMyDataToSink"},{"location":"Header/MamNodeApp/#broadcastsimplemessage","text":"virtual void broadcastSimpleMessage(const char *msg);","title":"broadcastSimpleMessage"},{"location":"Header/MamNodeApp/#broadcastsimplemessage_1","text":"virtual void broadcastSimpleMessage(const char *msg, int hops);","title":"broadcastSimpleMessage"},{"location":"Header/MamNodeApp/#sendsimplemessage","text":"virtual void sendSimpleMessage(const char *msg, L3Address &dest, int hops);","title":"sendSimpleMessage"},{"location":"Header/MamNodeApp/#handlestartoperation","text":"virtual void handleStartOperation(LifecycleOperation *operation) override;","title":"handleStartOperation"},{"location":"Header/MamNodeApp/#handlestopoperation","text":"virtual void handleStopOperation(LifecycleOperation *operation) override;","title":"handleStopOperation"},{"location":"Header/MamNodeApp/#handlecrashoperation","text":"virtual void handleCrashOperation(LifecycleOperation *operation) override;","title":"handleCrashOperation"},{"location":"Header/MamNodeApp/#socketdataarrived","text":"virtual void socketDataArrived(UdpSocket *socket, Packet *packet) override;","title":"socketDataArrived"},{"location":"Header/MamNodeApp/#socketerrorarrived","text":"virtual void socketErrorArrived(UdpSocket *socket, Indication *indication) override;","title":"socketErrorArrived"},{"location":"Header/MamNodeApp/#socketclosed","text":"virtual void socketClosed(UdpSocket *socket) override;","title":"socketClosed"},{"location":"Header/MamNodeApp/#random_char","text":"virtual unsigned int random_char();","title":"random_char"},{"location":"Header/MamNodeApp/#generate_hex","text":"virtual std::string generate_hex(const unsigned int len);","title":"generate_hex"},{"location":"Header/MamNodeApp/#mamnodeapp_1","text":"~MamNodeApp();","title":"~MamNodeApp"},{"location":"Header/MamNodeApp/#generate_uuid_v4","text":"virtual std::string generate_uuid_v4();","title":"generate_uuid_v4"},{"location":"Header/MobileNode/","text":"MobileNode Description Functions initialize virtual void initialize() override;","title":"MobileNode"},{"location":"Header/MobileNode/#mobilenode","text":"","title":"MobileNode"},{"location":"Header/MobileNode/#description","text":"","title":"Description"},{"location":"Header/MobileNode/#functions","text":"","title":"Functions"},{"location":"Header/MobileNode/#initialize","text":"virtual void initialize() override;","title":"initialize"},{"location":"Header/MobileSensorNode/","text":"MobileSensorNode Description Functions override;// virtual void initialize() override;//(int stage) override; handleMessage virtual void handleMessage(cMessage *msg); processMessage int processMessage(inet::Packet *msg); generateNextPacketToSend string generateNextPacketToSend();","title":"MobileSensorNode"},{"location":"Header/MobileSensorNode/#mobilesensornode","text":"","title":"MobileSensorNode"},{"location":"Header/MobileSensorNode/#description","text":"","title":"Description"},{"location":"Header/MobileSensorNode/#functions","text":"","title":"Functions"},{"location":"Header/MobileSensorNode/#override","text":"virtual void initialize() override;//(int stage) override;","title":"override;//"},{"location":"Header/MobileSensorNode/#handlemessage","text":"virtual void handleMessage(cMessage *msg);","title":"handleMessage"},{"location":"Header/MobileSensorNode/#processmessage","text":"int processMessage(inet::Packet *msg);","title":"processMessage"},{"location":"Header/MobileSensorNode/#generatenextpackettosend","text":"string generateNextPacketToSend();","title":"generateNextPacketToSend"},{"location":"Header/NetworkInterfaceExt/","text":"NetworkInterfaceExt Description Functions","title":"NetworkInterfaceExt"},{"location":"Header/NetworkInterfaceExt/#networkinterfaceext","text":"","title":"NetworkInterfaceExt"},{"location":"Header/NetworkInterfaceExt/#description","text":"","title":"Description"},{"location":"Header/NetworkInterfaceExt/#functions","text":"","title":"Functions"},{"location":"Header/PythonDroneMobility/","text":"PythonDroneMobility Description Functions cMessage cMessage *telemetryTimer = new cMessage(); initialize virtual void initialize(int stage) override; setInitialPosition virtual void setInitialPosition() override; move virtual void move() override; orient virtual void orient() override; fly virtual void fly(); virtual void climb (double targetHeight); handleMessage virtual void handleMessage(cMessage *message) override; sendTelemetry virtual void sendTelemetry();","title":"PythonDroneMobility"},{"location":"Header/PythonDroneMobility/#pythondronemobility","text":"","title":"PythonDroneMobility"},{"location":"Header/PythonDroneMobility/#description","text":"","title":"Description"},{"location":"Header/PythonDroneMobility/#functions","text":"","title":"Functions"},{"location":"Header/PythonDroneMobility/#cmessage","text":"cMessage *telemetryTimer = new cMessage();","title":"cMessage"},{"location":"Header/PythonDroneMobility/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/PythonDroneMobility/#setinitialposition","text":"virtual void setInitialPosition() override;","title":"setInitialPosition"},{"location":"Header/PythonDroneMobility/#move","text":"virtual void move() override;","title":"move"},{"location":"Header/PythonDroneMobility/#orient","text":"virtual void orient() override;","title":"orient"},{"location":"Header/PythonDroneMobility/#fly","text":"virtual void fly();","title":"fly"},{"location":"Header/PythonDroneMobility/#_1","text":"virtual void climb (double targetHeight);","title":""},{"location":"Header/PythonDroneMobility/#handlemessage","text":"virtual void handleMessage(cMessage *message) override;","title":"handleMessage"},{"location":"Header/PythonDroneMobility/#sendtelemetry","text":"virtual void sendTelemetry();","title":"sendTelemetry"},{"location":"Header/PythonDroneProtocol/","text":"PythonDroneProtocol Description Functions initialize virtual void initialize(int stage) override;","title":"PythonDroneProtocol"},{"location":"Header/PythonDroneProtocol/#pythondroneprotocol","text":"","title":"PythonDroneProtocol"},{"location":"Header/PythonDroneProtocol/#description","text":"","title":"Description"},{"location":"Header/PythonDroneProtocol/#functions","text":"","title":"Functions"},{"location":"Header/PythonDroneProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/PythonGroundProtocol/","text":"PythonGroundProtocol Description Functions initialize virtual void initialize(int stage) override;","title":"PythonGroundProtocol"},{"location":"Header/PythonGroundProtocol/#pythongroundprotocol","text":"","title":"PythonGroundProtocol"},{"location":"Header/PythonGroundProtocol/#description","text":"","title":"Description"},{"location":"Header/PythonGroundProtocol/#functions","text":"","title":"Functions"},{"location":"Header/PythonGroundProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/PythonSensorProtocol/","text":"PythonSensorProtocol Description Functions initialize virtual void initialize(int stage) override;","title":"PythonSensorProtocol"},{"location":"Header/PythonSensorProtocol/#pythonsensorprotocol","text":"","title":"PythonSensorProtocol"},{"location":"Header/PythonSensorProtocol/#description","text":"","title":"Description"},{"location":"Header/PythonSensorProtocol/#functions","text":"","title":"Functions"},{"location":"Header/PythonSensorProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/RandomFailureGenerator/","text":"RandomFailureGenerator Description Functions initialize virtual void initialize(); handleMessage virtual void handleMessage(cMessage *msg);","title":"RandomFailureGenerator"},{"location":"Header/RandomFailureGenerator/#randomfailuregenerator","text":"","title":"RandomFailureGenerator"},{"location":"Header/RandomFailureGenerator/#description","text":"","title":"Description"},{"location":"Header/RandomFailureGenerator/#functions","text":"","title":"Functions"},{"location":"Header/RandomFailureGenerator/#initialize","text":"virtual void initialize();","title":"initialize"},{"location":"Header/RandomFailureGenerator/#handlemessage","text":"virtual void handleMessage(cMessage *msg);","title":"handleMessage"},{"location":"Header/SimpleConsumptionEnergy/","text":"SimpleConsumptionEnergy Description Functions initialize virtual void initialize(int stage) override; handleMessage virtual void handleMessage(cMessage *msg) override;","title":"SimpleConsumptionEnergy"},{"location":"Header/SimpleConsumptionEnergy/#simpleconsumptionenergy","text":"","title":"SimpleConsumptionEnergy"},{"location":"Header/SimpleConsumptionEnergy/#description","text":"","title":"Description"},{"location":"Header/SimpleConsumptionEnergy/#functions","text":"","title":"Functions"},{"location":"Header/SimpleConsumptionEnergy/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/SimpleConsumptionEnergy/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/SimpleDroneProtocol/","text":"SimpleDroneProtocol Description Functions initialize virtual void initialize(int stage) override; Performs the initialization of our module. This is a function that most OMNeT++ modules will override finish virtual void finish() override; Called when the simulation finishes handlePacket virtual void handlePacket(Packet *pk) override; Gets called when a packet is recieved from the communication module updatePayload virtual void updatePayload(); Helper function that updates packet content with the current collected data","title":"SimpleDroneProtocol"},{"location":"Header/SimpleDroneProtocol/#simpledroneprotocol","text":"","title":"SimpleDroneProtocol"},{"location":"Header/SimpleDroneProtocol/#description","text":"","title":"Description"},{"location":"Header/SimpleDroneProtocol/#functions","text":"","title":"Functions"},{"location":"Header/SimpleDroneProtocol/#initialize","text":"virtual void initialize(int stage) override; Performs the initialization of our module. This is a function that most OMNeT++ modules will override","title":"initialize"},{"location":"Header/SimpleDroneProtocol/#finish","text":"virtual void finish() override; Called when the simulation finishes","title":"finish"},{"location":"Header/SimpleDroneProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Gets called when a packet is recieved from the communication module","title":"handlePacket"},{"location":"Header/SimpleDroneProtocol/#updatepayload","text":"virtual void updatePayload(); Helper function that updates packet content with the current collected data","title":"updatePayload"},{"location":"Header/SimpleGroundProtocol/","text":"SimpleGroundProtocol Description Functions initialize virtual void initialize(int stage) override; handlePacket virtual void handlePacket(Packet *pk) override;","title":"SimpleGroundProtocol"},{"location":"Header/SimpleGroundProtocol/#simplegroundprotocol","text":"","title":"SimpleGroundProtocol"},{"location":"Header/SimpleGroundProtocol/#description","text":"","title":"Description"},{"location":"Header/SimpleGroundProtocol/#functions","text":"","title":"Functions"},{"location":"Header/SimpleGroundProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/SimpleGroundProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override;","title":"handlePacket"},{"location":"Header/SimpleSensorProtocol/","text":"SimpleSensorProtocol Description Functions initialize virtual void initialize(int stage) override; Initialization function handlePacket virtual void handlePacket(Packet *pk) override; Handles packet recieved from the drone","title":"SimpleSensorProtocol"},{"location":"Header/SimpleSensorProtocol/#simplesensorprotocol","text":"","title":"SimpleSensorProtocol"},{"location":"Header/SimpleSensorProtocol/#description","text":"","title":"Description"},{"location":"Header/SimpleSensorProtocol/#functions","text":"","title":"Functions"},{"location":"Header/SimpleSensorProtocol/#initialize","text":"virtual void initialize(int stage) override; Initialization function","title":"initialize"},{"location":"Header/SimpleSensorProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override; Handles packet recieved from the drone","title":"handlePacket"},{"location":"Header/SimpleTimerEnergy/","text":"SimpleTimerEnergy Description Functions initialize virtual void initialize(int stage) override; handleMessage virtual void handleMessage(cMessage *msg) override; ~SimpleTimerEnergy virtual ~SimpleTimerEnergy();","title":"SimpleTimerEnergy"},{"location":"Header/SimpleTimerEnergy/#simpletimerenergy","text":"","title":"SimpleTimerEnergy"},{"location":"Header/SimpleTimerEnergy/#description","text":"","title":"Description"},{"location":"Header/SimpleTimerEnergy/#functions","text":"","title":"Functions"},{"location":"Header/SimpleTimerEnergy/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/SimpleTimerEnergy/#handlemessage","text":"virtual void handleMessage(cMessage *msg) override;","title":"handleMessage"},{"location":"Header/SimpleTimerEnergy/#simpletimerenergy_1","text":"virtual ~SimpleTimerEnergy();","title":"~SimpleTimerEnergy"},{"location":"Header/Singleton/","text":"Singleton Description Functions py::initialize_interpreter py::initialize_interpreter(); py::module_::import py::module_::import(\"sys\").attr(\"stdout\")); Singleton Singleton(Singleton &other) = delete; operator= void operator=(const Singleton&) = delete; GetInstance static Singleton* GetInstance(); TryCloseInstance static void TryCloseInstance();","title":"Singleton"},{"location":"Header/Singleton/#singleton","text":"","title":"Singleton"},{"location":"Header/Singleton/#description","text":"","title":"Description"},{"location":"Header/Singleton/#functions","text":"","title":"Functions"},{"location":"Header/Singleton/#pyinitialize_interpreter","text":"py::initialize_interpreter();","title":"py::initialize_interpreter"},{"location":"Header/Singleton/#pymodule_import","text":"py::module_::import(\"sys\").attr(\"stdout\"));","title":"py::module_::import"},{"location":"Header/Singleton/#singleton_1","text":"Singleton(Singleton &other) = delete;","title":"Singleton"},{"location":"Header/Singleton/#operator","text":"void operator=(const Singleton&) = delete;","title":"operator="},{"location":"Header/Singleton/#getinstance","text":"static Singleton* GetInstance();","title":"GetInstance"},{"location":"Header/Singleton/#trycloseinstance","text":"static void TryCloseInstance();","title":"TryCloseInstance"},{"location":"Header/TwoRayNewModel/","text":"TwoRayNewModel Description Functions TwoRayNewModel TwoRayNewModel(); initialize void initialize(int stage) override; computePathLoss double computePathLoss(const ITransmission*, const IArrival*) const override; computePathLoss double computePathLoss(mps propagation, Hz frequency, m distance) const override; computeRange m computeRange(mps propagation, Hz frequency, double loss) const override; printToStream std::ostream& printToStream(std::ostream&, int level, int evFlags) const override; computeTwoRayNewModel virtual double computeTwoRayNewModel(const Coord& posTx, const Coord& posRx, m waveLength) const; terraPlana virtual double terraPlana(const Coord& posTx, const Coord& posRx, m waveLength) const; terraEsferica virtual double terraEsferica(const Coord& posTx, const Coord& posRx, m waveLength) const;","title":"TwoRayNewModel"},{"location":"Header/TwoRayNewModel/#tworaynewmodel","text":"","title":"TwoRayNewModel"},{"location":"Header/TwoRayNewModel/#description","text":"","title":"Description"},{"location":"Header/TwoRayNewModel/#functions","text":"","title":"Functions"},{"location":"Header/TwoRayNewModel/#tworaynewmodel_1","text":"TwoRayNewModel();","title":"TwoRayNewModel"},{"location":"Header/TwoRayNewModel/#initialize","text":"void initialize(int stage) override;","title":"initialize"},{"location":"Header/TwoRayNewModel/#computepathloss","text":"double computePathLoss(const ITransmission*, const IArrival*) const override;","title":"computePathLoss"},{"location":"Header/TwoRayNewModel/#computepathloss_1","text":"double computePathLoss(mps propagation, Hz frequency, m distance) const override;","title":"computePathLoss"},{"location":"Header/TwoRayNewModel/#computerange","text":"m computeRange(mps propagation, Hz frequency, double loss) const override;","title":"computeRange"},{"location":"Header/TwoRayNewModel/#printtostream","text":"std::ostream& printToStream(std::ostream&, int level, int evFlags) const override;","title":"printToStream"},{"location":"Header/TwoRayNewModel/#computetworaynewmodel","text":"virtual double computeTwoRayNewModel(const Coord& posTx, const Coord& posRx, m waveLength) const;","title":"computeTwoRayNewModel"},{"location":"Header/TwoRayNewModel/#terraplana","text":"virtual double terraPlana(const Coord& posTx, const Coord& posRx, m waveLength) const;","title":"terraPlana"},{"location":"Header/TwoRayNewModel/#terraesferica","text":"virtual double terraEsferica(const Coord& posTx, const Coord& posRx, m waveLength) const;","title":"terraEsferica"},{"location":"Header/UdpCommunicationApp/","text":"UdpCommunicationApp Description Functions initialize virtual void initialize(int stage) override; setSocketOptions virtual void setSocketOptions() override; sendPacket virtual void sendPacket() override; sendPacket virtual void sendPacket(const FieldsChunk* payload, const char *target); processPacket virtual void processPacket(Packet *pk) override; handleMessageWhenUp virtual void handleMessageWhenUp(cMessage *msg) override;","title":"UdpCommunicationApp"},{"location":"Header/UdpCommunicationApp/#udpcommunicationapp","text":"","title":"UdpCommunicationApp"},{"location":"Header/UdpCommunicationApp/#description","text":"","title":"Description"},{"location":"Header/UdpCommunicationApp/#functions","text":"","title":"Functions"},{"location":"Header/UdpCommunicationApp/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/UdpCommunicationApp/#setsocketoptions","text":"virtual void setSocketOptions() override;","title":"setSocketOptions"},{"location":"Header/UdpCommunicationApp/#sendpacket","text":"virtual void sendPacket() override;","title":"sendPacket"},{"location":"Header/UdpCommunicationApp/#sendpacket_1","text":"virtual void sendPacket(const FieldsChunk* payload, const char *target);","title":"sendPacket"},{"location":"Header/UdpCommunicationApp/#processpacket","text":"virtual void processPacket(Packet *pk) override;","title":"processPacket"},{"location":"Header/UdpCommunicationApp/#handlemessagewhenup","text":"virtual void handleMessageWhenUp(cMessage *msg) override;","title":"handleMessageWhenUp"},{"location":"Header/ZigzagProtocol/","text":"ZigzagProtocol Description Functions Telemetry Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved Telemetry Telemetry lastStableTelemetry = Telemetry(); ZigzagMessage ZigzagMessage lastPayload = ZigzagMessage(); initialize virtual void initialize(int stage) override; handleTelemetry virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override; handlePacket virtual void handlePacket(Packet *pk) override; isTimedout virtual bool isTimedout() override; resetParameters virtual void resetParameters(); sendReverseOrder virtual void sendReverseOrder(); updatePayload virtual void updatePayload(); setTarget virtual void setTarget(const char *target);","title":"ZigzagProtocol"},{"location":"Header/ZigzagProtocol/#zigzagprotocol","text":"","title":"ZigzagProtocol"},{"location":"Header/ZigzagProtocol/#description","text":"","title":"Description"},{"location":"Header/ZigzagProtocol/#functions","text":"","title":"Functions"},{"location":"Header/ZigzagProtocol/#telemetry","text":"Telemetry currentTelemetry = Telemetry(); Last telemetry package recieved","title":"Telemetry"},{"location":"Header/ZigzagProtocol/#telemetry_1","text":"Telemetry lastStableTelemetry = Telemetry();","title":"Telemetry"},{"location":"Header/ZigzagProtocol/#zigzagmessage","text":"ZigzagMessage lastPayload = ZigzagMessage();","title":"ZigzagMessage"},{"location":"Header/ZigzagProtocol/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/ZigzagProtocol/#handletelemetry","text":"virtual void handleTelemetry(gradys_simulations::Telemetry *telemetry) override;","title":"handleTelemetry"},{"location":"Header/ZigzagProtocol/#handlepacket","text":"virtual void handlePacket(Packet *pk) override;","title":"handlePacket"},{"location":"Header/ZigzagProtocol/#istimedout","text":"virtual bool isTimedout() override;","title":"isTimedout"},{"location":"Header/ZigzagProtocol/#resetparameters","text":"virtual void resetParameters();","title":"resetParameters"},{"location":"Header/ZigzagProtocol/#sendreverseorder","text":"virtual void sendReverseOrder();","title":"sendReverseOrder"},{"location":"Header/ZigzagProtocol/#updatepayload","text":"virtual void updatePayload();","title":"updatePayload"},{"location":"Header/ZigzagProtocol/#settarget","text":"virtual void setTarget(const char *target);","title":"setTarget"},{"location":"Header/ZigzagProtocolSensor/","text":"ZigzagProtocolSensor Description Functions initialize virtual void initialize(int stage) override; handlePacket virtual void handlePacket(Packet *pk) override; updatePayload virtual void updatePayload(); setTarget virtual void setTarget(const char *target);","title":"ZigzagProtocolSensor"},{"location":"Header/ZigzagProtocolSensor/#zigzagprotocolsensor","text":"","title":"ZigzagProtocolSensor"},{"location":"Header/ZigzagProtocolSensor/#description","text":"","title":"Description"},{"location":"Header/ZigzagProtocolSensor/#functions","text":"","title":"Functions"},{"location":"Header/ZigzagProtocolSensor/#initialize","text":"virtual void initialize(int stage) override;","title":"initialize"},{"location":"Header/ZigzagProtocolSensor/#handlepacket","text":"virtual void handlePacket(Packet *pk) override;","title":"handlePacket"},{"location":"Header/ZigzagProtocolSensor/#updatepayload","text":"virtual void updatePayload();","title":"updatePayload"},{"location":"Header/ZigzagProtocolSensor/#settarget","text":"virtual void setTarget(const char *target);","title":"setTarget"},{"location":"Modules/BleMeshMac/","text":"BleMeshMac Description Parameters Name Type Unit Default value Description address string \"auto\" headerLength int b 72 b length of MAC header mtu int B 0B bitrate double bps 250000 bps bit rate ccaDetectionTime double s 0.000128 s Clear Channel Assessment detection time rxSetupTime double s 0 s Time to setup radio to reception state aTurnaroundTime double s 0.000192 s Time to switch radio from Rx to Tx state useMACAcks bool Send/Expect MAC acks for unicast traffic? macMaxFrameRetries int 3 Maximum number of frame retransmission, only used when usage of MAC acks is enabled. macAckWaitDuration double s 0.00056 s Time to wait for an acknowledgement after transmitting a unicast frame. Only used when usage of MAC acks is enabled. Value is calculated from 1+12+10+12 symbols, which is defined for nonbeacon-enabled PAN. In the non-beacon-enabled case, the receiver responds at aTurnaroundTime (i.e. the time for the sender and receiver to both be guaranteed to have switched from Tx to Rx and vice verse). This gives the value 192us + 352us = 544us (there's been some discussion about the \"extra\" 1 symbol == 16us) [section 7.5.6.4.2 of the specification]. ackLength int b 40 b Complete MAC ack message length (in bits) (! headerLength is not added to this), only used when usage of MAC acks is enabled. sifs double s 0.000192 s Simple interframe space (12 symbols). Time to wait between receiving a frame and acknowledging it. Should be bigger than the maximum time for switching between Tx and Rx at the receiver. Only used when usage of MAC acks is enabled. backoffMethod string \"linear\" Backoff method to use: constant, linear or exponential macMaxCSMABackoffs int 5 maximum number of extra backoffs (excluding the first unconditional one) before frame drop aUnitBackoffPeriod double s 0.00032 s base unit for all backoff calculations contentionWindow int 2 # of backoff periods of the initial contention window (for linear and constant backoff method only) macMinBE int 3 minimum backoff exponent (for exponential backoff method only) macMaxBE int 8 maximum backoff exponent (for exponential backoff method only) radioModule string \"^.radio\" lowPowerNode bool false","title":"BleMeshMac"},{"location":"Modules/BleMeshMac/#blemeshmac","text":"","title":"BleMeshMac"},{"location":"Modules/BleMeshMac/#description","text":"","title":"Description"},{"location":"Modules/BleMeshMac/#parameters","text":"Name Type Unit Default value Description address string \"auto\" headerLength int b 72 b length of MAC header mtu int B 0B bitrate double bps 250000 bps bit rate ccaDetectionTime double s 0.000128 s Clear Channel Assessment detection time rxSetupTime double s 0 s Time to setup radio to reception state aTurnaroundTime double s 0.000192 s Time to switch radio from Rx to Tx state useMACAcks bool Send/Expect MAC acks for unicast traffic? macMaxFrameRetries int 3 Maximum number of frame retransmission, only used when usage of MAC acks is enabled. macAckWaitDuration double s 0.00056 s Time to wait for an acknowledgement after transmitting a unicast frame. Only used when usage of MAC acks is enabled. Value is calculated from 1+12+10+12 symbols, which is defined for nonbeacon-enabled PAN. In the non-beacon-enabled case, the receiver responds at aTurnaroundTime (i.e. the time for the sender and receiver to both be guaranteed to have switched from Tx to Rx and vice verse). This gives the value 192us + 352us = 544us (there's been some discussion about the \"extra\" 1 symbol == 16us) [section 7.5.6.4.2 of the specification]. ackLength int b 40 b Complete MAC ack message length (in bits) (! headerLength is not added to this), only used when usage of MAC acks is enabled. sifs double s 0.000192 s Simple interframe space (12 symbols). Time to wait between receiving a frame and acknowledging it. Should be bigger than the maximum time for switching between Tx and Rx at the receiver. Only used when usage of MAC acks is enabled. backoffMethod string \"linear\" Backoff method to use: constant, linear or exponential macMaxCSMABackoffs int 5 maximum number of extra backoffs (excluding the first unconditional one) before frame drop aUnitBackoffPeriod double s 0.00032 s base unit for all backoff calculations contentionWindow int 2 # of backoff periods of the initial contention window (for linear and constant backoff method only) macMinBE int 3 minimum backoff exponent (for exponential backoff method only) macMaxBE int 8 maximum backoff exponent (for exponential backoff method only) radioModule string \"^.radio\" lowPowerNode bool false","title":"Parameters"},{"location":"Modules/BleMeshNarrowbandInterface/","text":"BleMeshNarrowbandInterface Description Parameters Name Type Unit Default value Description interfaceTableModule string energySourceModule string \"\"","title":"BleMeshNarrowbandInterface"},{"location":"Modules/BleMeshNarrowbandInterface/#blemeshnarrowbandinterface","text":"","title":"BleMeshNarrowbandInterface"},{"location":"Modules/BleMeshNarrowbandInterface/#description","text":"","title":"Description"},{"location":"Modules/BleMeshNarrowbandInterface/#parameters","text":"Name Type Unit Default value Description interfaceTableModule string energySourceModule string \"\"","title":"Parameters"},{"location":"Modules/BleMeshNarrowbandMac/","text":"BleMeshNarrowbandMac Description Parameters Name Type Unit Default value Description","title":"BleMeshNarrowbandMac"},{"location":"Modules/BleMeshNarrowbandMac/#blemeshnarrowbandmac","text":"","title":"BleMeshNarrowbandMac"},{"location":"Modules/BleMeshNarrowbandMac/#description","text":"","title":"Description"},{"location":"Modules/BleMeshNarrowbandMac/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/BleMeshUwbIrInterface/","text":"BleMeshUwbIrInterface Description Parameters Name Type Unit Default value Description interfaceTableModule string","title":"BleMeshUwbIrInterface"},{"location":"Modules/BleMeshUwbIrInterface/#blemeshuwbirinterface","text":"","title":"BleMeshUwbIrInterface"},{"location":"Modules/BleMeshUwbIrInterface/#description","text":"","title":"Description"},{"location":"Modules/BleMeshUwbIrInterface/#parameters","text":"Name Type Unit Default value Description interfaceTableModule string","title":"Parameters"},{"location":"Modules/CentralizedQLearning/","text":"CentralizedQLearning Description Parameters Name Type Unit Default value Description trainingMode bool true Flag that dictates if the module is run in training or testing mode. If set to true the module will use the hyper parameters below and train using a centralized Q learning algorithm. The output of this training is a Q Table exported after the simulation's end. Otherwise the module will import the Q Table and use it to make decisions. qTablePath string Path to the Centralized Q Table. If \"trainingMode\" is set to true the table is exported to this path, otherwise it is imported from this path. learningRate double 0.1 HyperParameters for the Centralized Q-Learning algorithm gamma double 0.99 epsilonDecayStrategy int 2 Defines the strategy used to decay epsilon. A decay stategy defines how the epsilon value will decay from 1 to 0. The possible strategies are: 1 = \"linear\" - In epsilonHorizon training steps epsilon will decay linearly from epsilonStart to epsilonEnd 2 = \"exponetial\" - In episilonHorizon training steps epsilon will decay exponentially from epsilonStart to epsilonEnd 3 = \"steps\" - In episilonHorizon training steps the episilon will decay by ((epsilonEnd - epsilonStart) / episilonSteps) every episilonSteps training steps epsilonStart double 1 epsilonEnd double 0.001 epsilonHorizon int 100000 epsilonSteps int 10 Only relevant to the \"steps\" strategy epsilonShortCircuit bool false If this boolean is set to true the simulation will automatically end when the epsilon horizon is reached startFromScratch bool true Determines if this simulation should start from scratch, ignoring any previous QTables, or if it should reuse and add knowledge to one, if available timeInterval double s 100ms Parameters for the simulated scenario distanceInterval double m 80m communicationStorageInterval double 80 sensorStorageTolerance double 80 The values stored in each of the indexes of the agent's local state are going to be divided by communicationStorageInterval and rounded up. maxDiscreteAgentPackets double 3 maxDiscreteAwaitingPackets double 3 costFunction double 1 agentWeight double 1 sensorWeight double 1 throughputWeight double 1","title":"CentralizedQLearning"},{"location":"Modules/CentralizedQLearning/#centralizedqlearning","text":"","title":"CentralizedQLearning"},{"location":"Modules/CentralizedQLearning/#description","text":"","title":"Description"},{"location":"Modules/CentralizedQLearning/#parameters","text":"Name Type Unit Default value Description trainingMode bool true Flag that dictates if the module is run in training or testing mode. If set to true the module will use the hyper parameters below and train using a centralized Q learning algorithm. The output of this training is a Q Table exported after the simulation's end. Otherwise the module will import the Q Table and use it to make decisions. qTablePath string Path to the Centralized Q Table. If \"trainingMode\" is set to true the table is exported to this path, otherwise it is imported from this path. learningRate double 0.1 HyperParameters for the Centralized Q-Learning algorithm gamma double 0.99 epsilonDecayStrategy int 2 Defines the strategy used to decay epsilon. A decay stategy defines how the epsilon value will decay from 1 to 0. The possible strategies are: 1 = \"linear\" - In epsilonHorizon training steps epsilon will decay linearly from epsilonStart to epsilonEnd 2 = \"exponetial\" - In episilonHorizon training steps epsilon will decay exponentially from epsilonStart to epsilonEnd 3 = \"steps\" - In episilonHorizon training steps the episilon will decay by ((epsilonEnd - epsilonStart) / episilonSteps) every episilonSteps training steps epsilonStart double 1 epsilonEnd double 0.001 epsilonHorizon int 100000 epsilonSteps int 10 Only relevant to the \"steps\" strategy epsilonShortCircuit bool false If this boolean is set to true the simulation will automatically end when the epsilon horizon is reached startFromScratch bool true Determines if this simulation should start from scratch, ignoring any previous QTables, or if it should reuse and add knowledge to one, if available timeInterval double s 100ms Parameters for the simulated scenario distanceInterval double m 80m communicationStorageInterval double 80 sensorStorageTolerance double 80 The values stored in each of the indexes of the agent's local state are going to be divided by communicationStorageInterval and rounded up. maxDiscreteAgentPackets double 3 maxDiscreteAwaitingPackets double 3 costFunction double 1 agentWeight double 1 sensorWeight double 1 throughputWeight double 1","title":"Parameters"},{"location":"Modules/CentralizedQProtocol/","text":"CentralizedQProtocol Description Parameters Name Type Unit Default value Description requestInterval double s 1s Interval at which general REQUEST messages are sent to the network communicationDelay double s 100ms Delay between communication commands and actual messages being sent. Actual delay will be exponentially close to this, randomized to prevent collision packetLimit int 1000","title":"CentralizedQProtocol"},{"location":"Modules/CentralizedQProtocol/#centralizedqprotocol","text":"","title":"CentralizedQProtocol"},{"location":"Modules/CentralizedQProtocol/#description","text":"","title":"Description"},{"location":"Modules/CentralizedQProtocol/#parameters","text":"Name Type Unit Default value Description requestInterval double s 1s Interval at which general REQUEST messages are sent to the network communicationDelay double s 100ms Delay between communication commands and actual messages being sent. Actual delay will be exponentially close to this, randomized to prevent collision packetLimit int 1000","title":"Parameters"},{"location":"Modules/CentralizedQProtocolGround/","text":"CentralizedQProtocolGround Description Parameters Name Type Unit Default value Description dataLoggingInterval double s 10s","title":"CentralizedQProtocolGround"},{"location":"Modules/CentralizedQProtocolGround/#centralizedqprotocolground","text":"","title":"CentralizedQProtocolGround"},{"location":"Modules/CentralizedQProtocolGround/#description","text":"","title":"Description"},{"location":"Modules/CentralizedQProtocolGround/#parameters","text":"Name Type Unit Default value Description dataLoggingInterval double s 10s","title":"Parameters"},{"location":"Modules/CentralizedQProtocolSensor/","text":"CentralizedQProtocolSensor Description Parameters Name Type Unit Default value Description beta double s 5s sensorPosition double 0.5 maxAwaitingPackets int 100","title":"CentralizedQProtocolSensor"},{"location":"Modules/CentralizedQProtocolSensor/#centralizedqprotocolsensor","text":"","title":"CentralizedQProtocolSensor"},{"location":"Modules/CentralizedQProtocolSensor/#description","text":"","title":"Description"},{"location":"Modules/CentralizedQProtocolSensor/#parameters","text":"Name Type Unit Default value Description beta double s 5s sensorPosition double 0.5 maxAwaitingPackets int 100","title":"Parameters"},{"location":"Modules/CommunicationProtocolBase/","text":"CommunicationProtocolBase Description Parameters Name Type Unit Default value Description","title":"CommunicationProtocolBase"},{"location":"Modules/CommunicationProtocolBase/#communicationprotocolbase","text":"","title":"CommunicationProtocolBase"},{"location":"Modules/CommunicationProtocolBase/#description","text":"","title":"Description"},{"location":"Modules/CommunicationProtocolBase/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/CommunicationProtocolPythonBase/","text":"CommunicationProtocolPythonBase Description Parameters Name Type Unit Default value Description","title":"CommunicationProtocolPythonBase"},{"location":"Modules/CommunicationProtocolPythonBase/#communicationprotocolpythonbase","text":"","title":"CommunicationProtocolPythonBase"},{"location":"Modules/CommunicationProtocolPythonBase/#description","text":"","title":"Description"},{"location":"Modules/CommunicationProtocolPythonBase/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/DadcaProtocol/","text":"DadcaProtocol Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s packetLimit int 1000","title":"DadcaProtocol"},{"location":"Modules/DadcaProtocol/#dadcaprotocol","text":"","title":"DadcaProtocol"},{"location":"Modules/DadcaProtocol/#description","text":"","title":"Description"},{"location":"Modules/DadcaProtocol/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s packetLimit int 1000","title":"Parameters"},{"location":"Modules/DadcaProtocolGround/","text":"DadcaProtocolGround Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s dataLoggingInterval double s 10s","title":"DadcaProtocolGround"},{"location":"Modules/DadcaProtocolGround/#dadcaprotocolground","text":"","title":"DadcaProtocolGround"},{"location":"Modules/DadcaProtocolGround/#description","text":"","title":"Description"},{"location":"Modules/DadcaProtocolGround/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s dataLoggingInterval double s 10s","title":"Parameters"},{"location":"Modules/DadcaProtocolSensor/","text":"DadcaProtocolSensor Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s generationInterval double s 5s","title":"DadcaProtocolSensor"},{"location":"Modules/DadcaProtocolSensor/#dadcaprotocolsensor","text":"","title":"DadcaProtocolSensor"},{"location":"Modules/DadcaProtocolSensor/#description","text":"","title":"Description"},{"location":"Modules/DadcaProtocolSensor/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s generationInterval double s 5s","title":"Parameters"},{"location":"Modules/DipoleAntennaCustom/","text":"DipoleAntennaCustom Description Parameters Name Type Unit Default value Description length double m wireAxis string \"z\" maxGain double dB the default value is Z axis, so that antenna mobility models are not required when antennas are approximately positioned in the same plane minGain double dB lambda double m","title":"DipoleAntennaCustom"},{"location":"Modules/DipoleAntennaCustom/#dipoleantennacustom","text":"","title":"DipoleAntennaCustom"},{"location":"Modules/DipoleAntennaCustom/#description","text":"","title":"Description"},{"location":"Modules/DipoleAntennaCustom/#parameters","text":"Name Type Unit Default value Description length double m wireAxis string \"z\" maxGain double dB the default value is Z axis, so that antenna mobility models are not required when antennas are approximately positioned in the same plane minGain double dB lambda double m","title":"Parameters"},{"location":"Modules/DroneMobility/","text":"DroneMobility Description Parameters Name Type Unit Default value Description yawSpeed double rad 5deg startTime double s 0s homeLatitude double degree homeLongitude double degree telemetryFrequency double s 1s","title":"DroneMobility"},{"location":"Modules/DroneMobility/#dronemobility","text":"","title":"DroneMobility"},{"location":"Modules/DroneMobility/#description","text":"","title":"Description"},{"location":"Modules/DroneMobility/#parameters","text":"Name Type Unit Default value Description yawSpeed double rad 5deg startTime double s 0s homeLatitude double degree homeLongitude double degree telemetryFrequency double s 1s","title":"Parameters"},{"location":"Modules/DroneMobilityMav/","text":"DroneMobilityMav Description Parameters Name Type Unit Default value Description startTime double s 0s waypointFile string waypointProximity double m speed double mps telemetryFrequency double s 1s","title":"DroneMobilityMav"},{"location":"Modules/DroneMobilityMav/#dronemobilitymav","text":"","title":"DroneMobilityMav"},{"location":"Modules/DroneMobilityMav/#description","text":"","title":"Description"},{"location":"Modules/DroneMobilityMav/#parameters","text":"Name Type Unit Default value Description startTime double s 0s waypointFile string waypointProximity double m speed double mps telemetryFrequency double s 1s","title":"Parameters"},{"location":"Modules/FailureGeneratorBase/","text":"FailureGeneratorBase Description Parameters Name Type Unit Default value Description","title":"FailureGeneratorBase"},{"location":"Modules/FailureGeneratorBase/#failuregeneratorbase","text":"","title":"FailureGeneratorBase"},{"location":"Modules/FailureGeneratorBase/#description","text":"","title":"Description"},{"location":"Modules/FailureGeneratorBase/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/GroundStation/","text":"GroundStation Description Parameters Name Type Unit Default value Description","title":"GroundStation"},{"location":"Modules/GroundStation/#groundstation","text":"","title":"GroundStation"},{"location":"Modules/GroundStation/#description","text":"","title":"Description"},{"location":"Modules/GroundStation/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/IFailureGenerator/","text":"IFailureGenerator Description Parameters Name Type Unit Default value Description","title":"IFailureGenerator"},{"location":"Modules/IFailureGenerator/#ifailuregenerator","text":"","title":"IFailureGenerator"},{"location":"Modules/IFailureGenerator/#description","text":"","title":"Description"},{"location":"Modules/IFailureGenerator/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/IProtocol/","text":"IProtocol Description Parameters Name Type Unit Default value Description","title":"IProtocol"},{"location":"Modules/IProtocol/#iprotocol","text":"","title":"IProtocol"},{"location":"Modules/IProtocol/#description","text":"","title":"Description"},{"location":"Modules/IProtocol/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/MAVLinkFileMobility/","text":"MAVLinkFileMobility Description Parameters Name Type Unit Default value Description waypointFile string Path to the waypoint mission file.","title":"MAVLinkFileMobility"},{"location":"Modules/MAVLinkFileMobility/#mavlinkfilemobility","text":"","title":"MAVLinkFileMobility"},{"location":"Modules/MAVLinkFileMobility/#description","text":"","title":"Description"},{"location":"Modules/MAVLinkFileMobility/#parameters","text":"Name Type Unit Default value Description waypointFile string Path to the waypoint mission file.","title":"Parameters"},{"location":"Modules/MAVLinkMobilityBase/","text":"MAVLinkMobilityBase Description Parameters Name Type Unit Default value Description systemId int 235 System ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID componentId int 235 Component ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID targetSystem int -1 systemId of this vehicle instance. This is a unique identifier of the simulated vehicle instance. You should take care not to repeat this ID if your simulation contains more than on MAVLinkMobility vehicle. By default will use -1, which sets the targetSystem to a unique ID. Be careful as this might conflict with other module's custom targetSystems. targetComponent int 1 componentId of this vehicle instance. Generally can be left as is. vehicleType int 1 MAVLink type of vehicle that this class represents COPTER=1 PLANE=2 ROVER=4 paramPath string Path for the parameters for this vehicle. Default parameters can be found for your vehicle type here . Be aware that incorrect parameters can prevent this vehicle from working. basePort int 5505 Base port for the SITL simulators. The actual PORT the simulators will be run is basePort + (targetSystem * 10) where targetSystem is the ID of the vehicle being simulated. If you don't want port comflicts set the same value for ALL MAVLink mobility modules and use different targetSystem for each of them. Or don't set basePort or targetSystem at all, the modules will automatically figura out ports that don't cause conflict. copterSimulatorPath string Path to the ArduCopter binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/CopterStable/ (WINDOWS) https://firmware.ardupilot.org/Copter/stable/SITL_x86_64_linux_gnu/ (LINUX) planeSimulatorPath string Path to the ArduPlane binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/PlaneStable/ (WINDOWS) https://firmware.ardupilot.org/Plane/stable/SITL_x86_64_linux_gnu/ (LINUX) roverSimulatorPath string // Path to the ArduRover binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/RoverStable/ (WINDOWS) https://firmware.ardupilot.org/Rover/stable/SITL_x86_64_linux_gnu/ (LINUX) Path to the Rover binary. Used to run simulator instances for this vehicle initialLatitude double deg -35.36326015deg Latitude of the initial position of the drone. The default value is the default home of the SITL simulator initialLongitude double deg 149.16523839deg Longitude of the initial position of the drone. The default value is the default home of the SITL simulator initialAltitude double m 0m Altitude of the initial position of the drone. waitUntilReady bool false Waits until the SITL vehicle is ready to arm before the simulation is able to start. Warning : If this option is set to true it may look like the simulation has crashed on startup. This is because, to my knowledge, the only way of preventing the simulation from starting before the vehicle is ready to arm is to intetionally freeze the module's initialization. Warning : This freeze may last for several minutes, depending on how many vehicles are being initiated and your machine's hardware.","title":"MAVLinkMobilityBase"},{"location":"Modules/MAVLinkMobilityBase/#mavlinkmobilitybase","text":"","title":"MAVLinkMobilityBase"},{"location":"Modules/MAVLinkMobilityBase/#description","text":"","title":"Description"},{"location":"Modules/MAVLinkMobilityBase/#parameters","text":"Name Type Unit Default value Description systemId int 235 System ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID componentId int 235 Component ID of this GCS. You do not need to change this unless you are trying to connect to the SITL instance with another GCS software that uses this ID targetSystem int -1 systemId of this vehicle instance. This is a unique identifier of the simulated vehicle instance. You should take care not to repeat this ID if your simulation contains more than on MAVLinkMobility vehicle. By default will use -1, which sets the targetSystem to a unique ID. Be careful as this might conflict with other module's custom targetSystems. targetComponent int 1 componentId of this vehicle instance. Generally can be left as is. vehicleType int 1 MAVLink type of vehicle that this class represents COPTER=1 PLANE=2 ROVER=4 paramPath string Path for the parameters for this vehicle. Default parameters can be found for your vehicle type here . Be aware that incorrect parameters can prevent this vehicle from working. basePort int 5505 Base port for the SITL simulators. The actual PORT the simulators will be run is basePort + (targetSystem * 10) where targetSystem is the ID of the vehicle being simulated. If you don't want port comflicts set the same value for ALL MAVLink mobility modules and use different targetSystem for each of them. Or don't set basePort or targetSystem at all, the modules will automatically figura out ports that don't cause conflict. copterSimulatorPath string Path to the ArduCopter binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/CopterStable/ (WINDOWS) https://firmware.ardupilot.org/Copter/stable/SITL_x86_64_linux_gnu/ (LINUX) planeSimulatorPath string Path to the ArduPlane binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/PlaneStable/ (WINDOWS) https://firmware.ardupilot.org/Plane/stable/SITL_x86_64_linux_gnu/ (LINUX) roverSimulatorPath string // Path to the ArduRover binary. Used to run simulator instances for this vehicle A stable version can be downloaded from: https://firmware.ardupilot.org/Tools/MissionPlanner/sitl/RoverStable/ (WINDOWS) https://firmware.ardupilot.org/Rover/stable/SITL_x86_64_linux_gnu/ (LINUX) Path to the Rover binary. Used to run simulator instances for this vehicle initialLatitude double deg -35.36326015deg Latitude of the initial position of the drone. The default value is the default home of the SITL simulator initialLongitude double deg 149.16523839deg Longitude of the initial position of the drone. The default value is the default home of the SITL simulator initialAltitude double m 0m Altitude of the initial position of the drone. waitUntilReady bool false Waits until the SITL vehicle is ready to arm before the simulation is able to start. Warning : If this option is set to true it may look like the simulation has crashed on startup. This is because, to my knowledge, the only way of preventing the simulation from starting before the vehicle is ready to arm is to intetionally freeze the module's initialization. Warning : This freeze may last for several minutes, depending on how many vehicles are being initiated and your machine's hardware.","title":"Parameters"},{"location":"Modules/MAVLinkRandomWaypointMobility/","text":"MAVLinkRandomWaypointMobility Description Parameters Name Type Unit Default value Description speed double mps 20mps Speed at which the vehicle should travel waitTime double s 0s Time the vehicle will wait before traveling to the next waypoint waypointRadius double m 30m Radius of the waypoint. Vehicles within this radius will be considered to have reached the waypoint","title":"MAVLinkRandomWaypointMobility"},{"location":"Modules/MAVLinkRandomWaypointMobility/#mavlinkrandomwaypointmobility","text":"","title":"MAVLinkRandomWaypointMobility"},{"location":"Modules/MAVLinkRandomWaypointMobility/#description","text":"","title":"Description"},{"location":"Modules/MAVLinkRandomWaypointMobility/#parameters","text":"Name Type Unit Default value Description speed double mps 20mps Speed at which the vehicle should travel waitTime double s 0s Time the vehicle will wait before traveling to the next waypoint waypointRadius double m 30m Radius of the waypoint. Vehicles within this radius will be considered to have reached the waypoint","title":"Parameters"},{"location":"Modules/MamDataCollectorApp/","text":"MamDataCollectorApp Description Parameters Name Type Unit Default value Description interfaceTableModule string startTime double s 0s stopTime double s -1s localPort int destPort int receiveBroadcast bool false multicastGroup string \"\" multicastSources string \"\" stopOperationExtraTime double s -1s stopOperationTimeout double s 2s sendDiscoveryInterval double s 1s dontFragment bool false dscp int -1 tos int -1 multicastInterface string \"\" joinLocalMulticastGroups bool false","title":"MamDataCollectorApp"},{"location":"Modules/MamDataCollectorApp/#mamdatacollectorapp","text":"","title":"MamDataCollectorApp"},{"location":"Modules/MamDataCollectorApp/#description","text":"","title":"Description"},{"location":"Modules/MamDataCollectorApp/#parameters","text":"Name Type Unit Default value Description interfaceTableModule string startTime double s 0s stopTime double s -1s localPort int destPort int receiveBroadcast bool false multicastGroup string \"\" multicastSources string \"\" stopOperationExtraTime double s -1s stopOperationTimeout double s 2s sendDiscoveryInterval double s 1s dontFragment bool false dscp int -1 tos int -1 multicastInterface string \"\" joinLocalMulticastGroups bool false","title":"Parameters"},{"location":"Modules/MamNodeApp/","text":"MamNodeApp Description Parameters Name Type Unit Default value Description interfaceTableModule string localPort int -1 destAddresses string \"\" localAddress string \"\" packetName string \"UdpBasicAppData\" destPort int messageLength int B startTime double s this.sendInterval stopTime double s -1s sendInterval double s timeToLive int -1 dontFragment bool false dscp int -1 tos int -1 multicastInterface string \"\" relayNode bool false typeOfService int -1 joinLocalMulticastGroups bool false stopOperationExtraTime double s -1s stopOperationTimeout double s 2s relayMode string \"MAM\" lowPowerNode bool false friendNode bool false delta int","title":"MamNodeApp"},{"location":"Modules/MamNodeApp/#mamnodeapp","text":"","title":"MamNodeApp"},{"location":"Modules/MamNodeApp/#description","text":"","title":"Description"},{"location":"Modules/MamNodeApp/#parameters","text":"Name Type Unit Default value Description interfaceTableModule string localPort int -1 destAddresses string \"\" localAddress string \"\" packetName string \"UdpBasicAppData\" destPort int messageLength int B startTime double s this.sendInterval stopTime double s -1s sendInterval double s timeToLive int -1 dontFragment bool false dscp int -1 tos int -1 multicastInterface string \"\" relayNode bool false typeOfService int -1 joinLocalMulticastGroups bool false stopOperationExtraTime double s -1s stopOperationTimeout double s 2s relayMode string \"MAM\" lowPowerNode bool false friendNode bool false delta int","title":"Parameters"},{"location":"Modules/MobileNode/","text":"MobileNode Description Parameters Name Type Unit Default value Description numFailures int 0","title":"MobileNode"},{"location":"Modules/MobileNode/#mobilenode","text":"","title":"MobileNode"},{"location":"Modules/MobileNode/#description","text":"","title":"Description"},{"location":"Modules/MobileNode/#parameters","text":"Name Type Unit Default value Description numFailures int 0","title":"Parameters"},{"location":"Modules/MobileNodeMam/","text":"MobileNodeMam Description Parameters Name Type Unit Default value Description numFailures int 0","title":"MobileNodeMam"},{"location":"Modules/MobileNodeMam/#mobilenodemam","text":"","title":"MobileNodeMam"},{"location":"Modules/MobileNodeMam/#description","text":"","title":"Description"},{"location":"Modules/MobileNodeMam/#parameters","text":"Name Type Unit Default value Description numFailures int 0","title":"Parameters"},{"location":"Modules/MobileSensorNode/","text":"MobileSensorNode Description Parameters Name Type Unit Default value Description","title":"MobileSensorNode"},{"location":"Modules/MobileSensorNode/#mobilesensornode","text":"","title":"MobileSensorNode"},{"location":"Modules/MobileSensorNode/#description","text":"","title":"Description"},{"location":"Modules/MobileSensorNode/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/PythonDroneMobility/","text":"PythonDroneMobility Description Parameters Name Type Unit Default value Description speed double mps groundModule string \"environment.ground\" initialX double m uniform(constraintAreaMinX, constraintAreaMaxX) initialY double m uniform(constraintAreaMinY, constraintAreaMaxY) initialZ double m nanToZero(uniform(constraintAreaMinZ, constraintAreaMaxZ)) initFromDisplayString bool true initialLongitude double deg 0deg initialLatitude double deg 0deg startTime double s 0s telemetryFrequency double s 1s","title":"PythonDroneMobility"},{"location":"Modules/PythonDroneMobility/#pythondronemobility","text":"","title":"PythonDroneMobility"},{"location":"Modules/PythonDroneMobility/#description","text":"","title":"Description"},{"location":"Modules/PythonDroneMobility/#parameters","text":"Name Type Unit Default value Description speed double mps groundModule string \"environment.ground\" initialX double m uniform(constraintAreaMinX, constraintAreaMaxX) initialY double m uniform(constraintAreaMinY, constraintAreaMaxY) initialZ double m nanToZero(uniform(constraintAreaMinZ, constraintAreaMaxZ)) initFromDisplayString bool true initialLongitude double deg 0deg initialLatitude double deg 0deg startTime double s 0s telemetryFrequency double s 1s","title":"Parameters"},{"location":"Modules/PythonDroneProtocol/","text":"PythonDroneProtocol Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s customProtocolLocation string protocol string protocolFileName string protocolMobile string","title":"PythonDroneProtocol"},{"location":"Modules/PythonDroneProtocol/#pythondroneprotocol","text":"","title":"PythonDroneProtocol"},{"location":"Modules/PythonDroneProtocol/#description","text":"","title":"Description"},{"location":"Modules/PythonDroneProtocol/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s customProtocolLocation string protocol string protocolFileName string protocolMobile string","title":"Parameters"},{"location":"Modules/PythonGroundProtocol/","text":"PythonGroundProtocol Description Parameters Name Type Unit Default value Description customProtocolLocation string protocol string protocolFileName string protocolGround string","title":"PythonGroundProtocol"},{"location":"Modules/PythonGroundProtocol/#pythongroundprotocol","text":"","title":"PythonGroundProtocol"},{"location":"Modules/PythonGroundProtocol/#description","text":"","title":"Description"},{"location":"Modules/PythonGroundProtocol/#parameters","text":"Name Type Unit Default value Description customProtocolLocation string protocol string protocolFileName string protocolGround string","title":"Parameters"},{"location":"Modules/PythonSensorProtocol/","text":"PythonSensorProtocol Description Parameters Name Type Unit Default value Description customProtocolLocation string protocol string protocolFileName string protocolSensor string","title":"PythonSensorProtocol"},{"location":"Modules/PythonSensorProtocol/#pythonsensorprotocol","text":"","title":"PythonSensorProtocol"},{"location":"Modules/PythonSensorProtocol/#description","text":"","title":"Description"},{"location":"Modules/PythonSensorProtocol/#parameters","text":"Name Type Unit Default value Description customProtocolLocation string protocol string protocolFileName string protocolSensor string","title":"Parameters"},{"location":"Modules/RandomFailureGenerator/","text":"RandomFailureGenerator Description Parameters Name Type Unit Default value Description failureMinimumInterval double s 0s Minimum interval between failures failureRollTime double s 1s Time between failure rolls failureChance double Chance of failure every roll failureDuration double s 15s Duration of a failure, normal operation will resume afterwards","title":"RandomFailureGenerator"},{"location":"Modules/RandomFailureGenerator/#randomfailuregenerator","text":"","title":"RandomFailureGenerator"},{"location":"Modules/RandomFailureGenerator/#description","text":"","title":"Description"},{"location":"Modules/RandomFailureGenerator/#parameters","text":"Name Type Unit Default value Description failureMinimumInterval double s 0s Minimum interval between failures failureRollTime double s 1s Time between failure rolls failureChance double Chance of failure every roll failureDuration double s 15s Duration of a failure, normal operation will resume afterwards","title":"Parameters"},{"location":"Modules/SimpleConsumptionEnergy/","text":"SimpleConsumptionEnergy Description Parameters Name Type Unit Default value Description batteryCapacity double mAh batteryRTLThreshold double mAh Battery threshold to send the drone home batteryConsumption double A Vehicle's energy consumption rechargeDuration double s Time the vehicle will spend home recharging","title":"SimpleConsumptionEnergy"},{"location":"Modules/SimpleConsumptionEnergy/#simpleconsumptionenergy","text":"","title":"SimpleConsumptionEnergy"},{"location":"Modules/SimpleConsumptionEnergy/#description","text":"","title":"Description"},{"location":"Modules/SimpleConsumptionEnergy/#parameters","text":"Name Type Unit Default value Description batteryCapacity double mAh batteryRTLThreshold double mAh Battery threshold to send the drone home batteryConsumption double A Vehicle's energy consumption rechargeDuration double s Time the vehicle will spend home recharging","title":"Parameters"},{"location":"Modules/SimpleDroneProtocol/","text":"SimpleDroneProtocol Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s","title":"SimpleDroneProtocol"},{"location":"Modules/SimpleDroneProtocol/#simpledroneprotocol","text":"","title":"SimpleDroneProtocol"},{"location":"Modules/SimpleDroneProtocol/#description","text":"","title":"Description"},{"location":"Modules/SimpleDroneProtocol/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s","title":"Parameters"},{"location":"Modules/SimpleGroundProtocol/","text":"SimpleGroundProtocol Description Parameters Name Type Unit Default value Description","title":"SimpleGroundProtocol"},{"location":"Modules/SimpleGroundProtocol/#simplegroundprotocol","text":"","title":"SimpleGroundProtocol"},{"location":"Modules/SimpleGroundProtocol/#description","text":"","title":"Description"},{"location":"Modules/SimpleGroundProtocol/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/SimpleSensorProtocol/","text":"SimpleSensorProtocol Description Parameters Name Type Unit Default value Description payloadSize int 5","title":"SimpleSensorProtocol"},{"location":"Modules/SimpleSensorProtocol/#simplesensorprotocol","text":"","title":"SimpleSensorProtocol"},{"location":"Modules/SimpleSensorProtocol/#description","text":"","title":"Description"},{"location":"Modules/SimpleSensorProtocol/#parameters","text":"Name Type Unit Default value Description payloadSize int 5","title":"Parameters"},{"location":"Modules/SimpleTimerEnergy/","text":"SimpleTimerEnergy Description Parameters Name Type Unit Default value Description batteryShutdownDuration double s batteryRTLDuration double s rechargeDuration double s 3s","title":"SimpleTimerEnergy"},{"location":"Modules/SimpleTimerEnergy/#simpletimerenergy","text":"","title":"SimpleTimerEnergy"},{"location":"Modules/SimpleTimerEnergy/#description","text":"","title":"Description"},{"location":"Modules/SimpleTimerEnergy/#parameters","text":"Name Type Unit Default value Description batteryShutdownDuration double s batteryRTLDuration double s rechargeDuration double s 3s","title":"Parameters"},{"location":"Modules/TwoRayNewModel/","text":"TwoRayNewModel Description Parameters Name Type Unit Default value Description epsilon_r double 15 sigma double 0.005 delta_h double 0.05 polarization string \"horizontal\"","title":"TwoRayNewModel"},{"location":"Modules/TwoRayNewModel/#tworaynewmodel","text":"","title":"TwoRayNewModel"},{"location":"Modules/TwoRayNewModel/#description","text":"","title":"Description"},{"location":"Modules/TwoRayNewModel/#parameters","text":"Name Type Unit Default value Description epsilon_r double 15 sigma double 0.005 delta_h double 0.05 polarization string \"horizontal\"","title":"Parameters"},{"location":"Modules/UdpCommunicationApp/","text":"UdpCommunicationApp Description Parameters Name Type Unit Default value Description","title":"UdpCommunicationApp"},{"location":"Modules/UdpCommunicationApp/#udpcommunicationapp","text":"","title":"UdpCommunicationApp"},{"location":"Modules/UdpCommunicationApp/#description","text":"","title":"Description"},{"location":"Modules/UdpCommunicationApp/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"},{"location":"Modules/ZigzagProtocol/","text":"ZigzagProtocol Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s","title":"ZigzagProtocol"},{"location":"Modules/ZigzagProtocol/#zigzagprotocol","text":"","title":"ZigzagProtocol"},{"location":"Modules/ZigzagProtocol/#description","text":"","title":"Description"},{"location":"Modules/ZigzagProtocol/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s","title":"Parameters"},{"location":"Modules/ZigzagProtocolSensor/","text":"ZigzagProtocolSensor Description Parameters Name Type Unit Default value Description timeoutDuration double s 3s","title":"ZigzagProtocolSensor"},{"location":"Modules/ZigzagProtocolSensor/#zigzagprotocolsensor","text":"","title":"ZigzagProtocolSensor"},{"location":"Modules/ZigzagProtocolSensor/#description","text":"","title":"Description"},{"location":"Modules/ZigzagProtocolSensor/#parameters","text":"Name Type Unit Default value Description timeoutDuration double s 3s","title":"Parameters"},{"location":"Modules/package/","text":"package Description Parameters Name Type Unit Default value Description","title":"package"},{"location":"Modules/package/#package","text":"","title":"package"},{"location":"Modules/package/#description","text":"","title":"Description"},{"location":"Modules/package/#parameters","text":"Name Type Unit Default value Description","title":"Parameters"}]}